<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>cocos2d-iphone-2.1-beta4: /Bing/File/cocos2d/cocos2d-iphone/cocos2d-iphone-2.1-beta4/external/SpiderMonkey/osx/include/js/HashTable.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="Icon.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos2d-iphone-2.1-beta4
   &#160;<span id="projectnumber">2.1-beta4</span>
   </div>
   <div id="projectbrief">zhxubing@gmail.com</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('osx_2include_2js_2_hash_table_8h.html','');
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/Bing/File/cocos2d/cocos2d-iphone/cocos2d-iphone-2.1-beta4/external/SpiderMonkey/osx/include/js/HashTable.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-</span>
<a name="l00002"></a>00002 <span class="comment"> * vim: set ts=8 sw=4 et tw=99 ft=cpp:</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * This Source Code Form is subject to the terms of the Mozilla Public</span>
<a name="l00005"></a>00005 <span class="comment"> * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a name="l00006"></a>00006 <span class="comment"> * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#ifndef jshashtable_h_</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#define jshashtable_h_</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;TemplateLib.h&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;Utility.h&quot;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="keyword">namespace </span>js {
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="keyword">class </span>TempAllocPolicy;
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="comment">/*****************************************************************************/</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="keyword">namespace </span>detail {
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> HashPolicy, <span class="keyword">class</span> AllocPolicy&gt;
<a name="l00023"></a>00023 <span class="keyword">class </span>HashTable;
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00026"></a>00026 <span class="keyword">class </span>HashTableEntry {
<a name="l00027"></a>00027     HashNumber keyHash;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029     <span class="keyword">typedef</span> <span class="keyword">typename</span> tl::StripConst&lt;T&gt;::result NonConstT;
<a name="l00030"></a>00030 
<a name="l00031"></a>00031     <span class="keyword">static</span> <span class="keyword">const</span> HashNumber sFreeKey = 0;
<a name="l00032"></a>00032     <span class="keyword">static</span> <span class="keyword">const</span> HashNumber sRemovedKey = 1;
<a name="l00033"></a>00033     <span class="keyword">static</span> <span class="keyword">const</span> HashNumber sCollisionBit = 1;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035     <span class="keyword">template</span> &lt;<span class="keyword">class</span>, <span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">friend</span> <span class="keyword">class </span>HashTable;
<a name="l00036"></a>00036 
<a name="l00037"></a>00037     <span class="keyword">static</span> <span class="keywordtype">bool</span> isLiveHash(HashNumber hash)
<a name="l00038"></a>00038     {
<a name="l00039"></a>00039         <span class="keywordflow">return</span> hash &gt; sRemovedKey;
<a name="l00040"></a>00040     }
<a name="l00041"></a>00041 
<a name="l00042"></a>00042   <span class="keyword">public</span>:
<a name="l00043"></a>00043     HashTableEntry() : keyHash(0), t() {}
<a name="l00044"></a>00044     HashTableEntry(MoveRef&lt;HashTableEntry&gt; rhs) : keyHash(rhs-&gt;keyHash), t(Move(rhs-&gt;t)) { }
<a name="l00045"></a>00045     <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> HashTableEntry &amp;rhs) { keyHash = rhs.keyHash; t = rhs.t; }
<a name="l00046"></a>00046     <span class="keywordtype">void</span> operator=(MoveRef&lt;HashTableEntry&gt; rhs) { keyHash = rhs-&gt;keyHash; t = Move(rhs-&gt;t); }
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     NonConstT t;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050     <span class="keywordtype">bool</span> isFree()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> keyHash == sFreeKey; }
<a name="l00051"></a>00051     <span class="keywordtype">void</span> setFree()                { keyHash = sFreeKey; t = T(); }
<a name="l00052"></a>00052     <span class="keywordtype">bool</span> isRemoved()<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> keyHash == sRemovedKey; }
<a name="l00053"></a>00053     <span class="keywordtype">void</span> setRemoved()             { keyHash = sRemovedKey; t = T(); }
<a name="l00054"></a>00054     <span class="keywordtype">bool</span> isLive()<span class="keyword"> const           </span>{ <span class="keywordflow">return</span> isLiveHash(keyHash); }
<a name="l00055"></a>00055     <span class="keywordtype">void</span> setLive(HashNumber hn)   { JS_ASSERT(isLiveHash(hn)); keyHash = hn; }
<a name="l00056"></a>00056 
<a name="l00057"></a>00057     <span class="keywordtype">void</span> setCollision()           { JS_ASSERT(isLive()); keyHash |= sCollisionBit; }
<a name="l00058"></a>00058     <span class="keywordtype">void</span> setCollision(HashNumber collisionBit) {
<a name="l00059"></a>00059         JS_ASSERT(isLive()); keyHash |= collisionBit;
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061     <span class="keywordtype">void</span> unsetCollision()         { keyHash &amp;= ~sCollisionBit; }
<a name="l00062"></a>00062     <span class="keywordtype">bool</span> hasCollision()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> keyHash &amp; sCollisionBit; }
<a name="l00063"></a>00063     <span class="keywordtype">bool</span> matchHash(HashNumber hn) { <span class="keywordflow">return</span> (keyHash &amp; ~sCollisionBit) == hn; }
<a name="l00064"></a>00064     HashNumber getKeyHash()<span class="keyword"> const </span>{ JS_ASSERT(!hasCollision()); <span class="keywordflow">return</span> keyHash; }
<a name="l00065"></a>00065 };
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="comment">/*</span>
<a name="l00068"></a>00068 <span class="comment"> * js::detail::HashTable is an implementation detail of the js::HashMap and</span>
<a name="l00069"></a>00069 <span class="comment"> * js::HashSet templates. For js::Hash{Map,Set} API documentation and examples,</span>
<a name="l00070"></a>00070 <span class="comment"> * skip to the end of the detail namespace.</span>
<a name="l00071"></a>00071 <span class="comment"> */</span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="comment">/* Reusable implementation of HashMap and HashSet. */</span>
<a name="l00074"></a>00074 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> HashPolicy, <span class="keyword">class</span> AllocPolicy&gt;
<a name="l00075"></a>00075 <span class="keyword">class </span>HashTable : <span class="keyword">private</span> <a class="code" href="class_alloc_policy.html">AllocPolicy</a>
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077     <span class="keyword">typedef</span> <span class="keyword">typename</span> tl::StripConst&lt;T&gt;::result NonConstT;
<a name="l00078"></a>00078     <span class="keyword">typedef</span> <span class="keyword">typename</span> HashPolicy::KeyType Key;
<a name="l00079"></a>00079     <span class="keyword">typedef</span> <span class="keyword">typename</span> HashPolicy::Lookup Lookup;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   <span class="keyword">public</span>:
<a name="l00082"></a>00082     <span class="keyword">typedef</span> HashTableEntry&lt;T&gt; Entry;
<a name="l00083"></a>00083 
<a name="l00084"></a>00084     <span class="comment">/*</span>
<a name="l00085"></a>00085 <span class="comment">     * A nullable pointer to a hash table element. A Ptr |p| can be tested</span>
<a name="l00086"></a>00086 <span class="comment">     * either explicitly |if (p.found()) p-&gt;...| or using boolean conversion</span>
<a name="l00087"></a>00087 <span class="comment">     * |if (p) p-&gt;...|. Ptr objects must not be used after any mutating hash</span>
<a name="l00088"></a>00088 <span class="comment">     * table operations unless |generation()| is tested.</span>
<a name="l00089"></a>00089 <span class="comment">     */</span>
<a name="l00090"></a>00090     <span class="keyword">class </span>Ptr
<a name="l00091"></a>00091     {
<a name="l00092"></a>00092         <span class="keyword">friend</span> <span class="keyword">class </span>HashTable;
<a name="l00093"></a>00093         <span class="keyword">typedef</span> void (Ptr::* ConvertibleToBool)();
<a name="l00094"></a>00094         <span class="keywordtype">void</span> nonNull() {}
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         Entry *entry;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098       <span class="keyword">protected</span>:
<a name="l00099"></a>00099         Ptr(Entry &amp;entry) : entry(&amp;entry) {}
<a name="l00100"></a>00100 
<a name="l00101"></a>00101       <span class="keyword">public</span>:
<a name="l00102"></a>00102         <span class="comment">/* Leaves Ptr uninitialized. */</span>
<a name="l00103"></a>00103         Ptr() {
<a name="l00104"></a>00104 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span>            entry = (Entry *)0xbad;
<a name="l00106"></a>00106 <span class="preprocessor">#endif</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span>        }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109         <span class="keywordtype">bool</span> found()<span class="keyword"> const                    </span>{ <span class="keywordflow">return</span> entry-&gt;isLive(); }
<a name="l00110"></a>00110         operator ConvertibleToBool()<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> found() ? &amp;Ptr::nonNull : 0; }
<a name="l00111"></a>00111         <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Ptr &amp;rhs)<span class="keyword"> const </span>{ JS_ASSERT(found() &amp;&amp; rhs.found()); <span class="keywordflow">return</span> entry == rhs.entry; }
<a name="l00112"></a>00112         <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> Ptr &amp;rhs)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == rhs); }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         T &amp;operator*()<span class="keyword"> const                  </span>{ <span class="keywordflow">return</span> entry-&gt;t; }
<a name="l00115"></a>00115         T *operator-&gt;()<span class="keyword"> const                 </span>{ <span class="keywordflow">return</span> &amp;entry-&gt;t; }
<a name="l00116"></a>00116     };
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <span class="comment">/* A Ptr that can be used to add a key after a failed lookup. */</span>
<a name="l00119"></a>00119     <span class="keyword">class </span>AddPtr : <span class="keyword">public</span> Ptr
<a name="l00120"></a>00120     {
<a name="l00121"></a>00121         <span class="keyword">friend</span> <span class="keyword">class </span>HashTable;
<a name="l00122"></a>00122         HashNumber keyHash;
<a name="l00123"></a>00123         DebugOnly&lt;uint64_t&gt; mutationCount;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125         AddPtr(Entry &amp;entry, HashNumber hn) : Ptr(entry), keyHash(hn) {}
<a name="l00126"></a>00126       <span class="keyword">public</span>:
<a name="l00127"></a>00127         <span class="comment">/* Leaves AddPtr uninitialized. */</span>
<a name="l00128"></a>00128         AddPtr() {}
<a name="l00129"></a>00129     };
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="comment">/*</span>
<a name="l00132"></a>00132 <span class="comment">     * A collection of hash table entries. The collection is enumerated by</span>
<a name="l00133"></a>00133 <span class="comment">     * calling |front()| followed by |popFront()| as long as |!empty()|. As</span>
<a name="l00134"></a>00134 <span class="comment">     * with Ptr/AddPtr, Range objects must not be used after any mutating hash</span>
<a name="l00135"></a>00135 <span class="comment">     * table operation unless the |generation()| is tested.</span>
<a name="l00136"></a>00136 <span class="comment">     */</span>
<a name="l00137"></a>00137     <span class="keyword">class </span>Range
<a name="l00138"></a>00138     {
<a name="l00139"></a>00139       <span class="keyword">protected</span>:
<a name="l00140"></a>00140         <span class="keyword">friend</span> <span class="keyword">class </span>HashTable;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142         Range(Entry *c, Entry *e) : cur(c), end(e), validEntry(true) {
<a name="l00143"></a>00143             <span class="keywordflow">while</span> (cur &lt; end &amp;&amp; !cur-&gt;isLive())
<a name="l00144"></a>00144                 ++cur;
<a name="l00145"></a>00145         }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147         Entry *cur, *end;
<a name="l00148"></a>00148         DebugOnly&lt;bool&gt; validEntry;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150       <span class="keyword">public</span>:
<a name="l00151"></a>00151         Range() : cur(NULL), end(NULL), validEntry(false) {}
<a name="l00152"></a>00152 
<a name="l00153"></a>00153         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{
<a name="l00154"></a>00154             <span class="keywordflow">return</span> cur == end;
<a name="l00155"></a>00155         }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157         T &amp;front()<span class="keyword"> const </span>{
<a name="l00158"></a>00158             JS_ASSERT(validEntry);
<a name="l00159"></a>00159             JS_ASSERT(!empty());
<a name="l00160"></a>00160             <span class="keywordflow">return</span> cur-&gt;t;
<a name="l00161"></a>00161         }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163         <span class="keywordtype">void</span> popFront() {
<a name="l00164"></a>00164             JS_ASSERT(!empty());
<a name="l00165"></a>00165             <span class="keywordflow">while</span> (++cur &lt; end &amp;&amp; !cur-&gt;isLive())
<a name="l00166"></a>00166                 <span class="keywordflow">continue</span>;
<a name="l00167"></a>00167             validEntry = <span class="keyword">true</span>;
<a name="l00168"></a>00168         }
<a name="l00169"></a>00169     };
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="comment">/*</span>
<a name="l00172"></a>00172 <span class="comment">     * A Range whose lifetime delimits a mutating enumeration of a hash table.</span>
<a name="l00173"></a>00173 <span class="comment">     * Since rehashing when elements were removed during enumeration would be</span>
<a name="l00174"></a>00174 <span class="comment">     * bad, it is postponed until |endEnumeration()| is called. If</span>
<a name="l00175"></a>00175 <span class="comment">     * |endEnumeration()| is not called before an Enum&#39;s constructor, it will</span>
<a name="l00176"></a>00176 <span class="comment">     * be called automatically. Since |endEnumeration()| touches the hash</span>
<a name="l00177"></a>00177 <span class="comment">     * table, the user must ensure that the hash table is still alive when this</span>
<a name="l00178"></a>00178 <span class="comment">     * happens.</span>
<a name="l00179"></a>00179 <span class="comment">     */</span>
<a name="l00180"></a>00180     <span class="keyword">class </span>Enum : <span class="keyword">public</span> Range
<a name="l00181"></a>00181     {
<a name="l00182"></a>00182         <span class="keyword">friend</span> <span class="keyword">class </span>HashTable;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         HashTable &amp;table;
<a name="l00185"></a>00185         <span class="keywordtype">bool</span> rekeyed;
<a name="l00186"></a>00186         <span class="keywordtype">bool</span> removed;
<a name="l00187"></a>00187 
<a name="l00188"></a>00188         <span class="comment">/* Not copyable. */</span>
<a name="l00189"></a>00189         Enum(<span class="keyword">const</span> Enum &amp;);
<a name="l00190"></a>00190         <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> Enum &amp;);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192       <span class="keyword">public</span>:
<a name="l00193"></a>00193         <span class="keyword">template</span>&lt;<span class="keyword">class</span> Map&gt; <span class="keyword">explicit</span>
<a name="l00194"></a>00194         Enum(Map &amp;map) : Range(map.all()), table(map.impl), rekeyed(false), removed(false) {}
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         <span class="comment">/*</span>
<a name="l00197"></a>00197 <span class="comment">         * Removes the |front()| element from the table, leaving |front()|</span>
<a name="l00198"></a>00198 <span class="comment">         * invalid until the next call to |popFront()|. For example:</span>
<a name="l00199"></a>00199 <span class="comment">         *</span>
<a name="l00200"></a>00200 <span class="comment">         *   HashSet&lt;int&gt; s;</span>
<a name="l00201"></a>00201 <span class="comment">         *   for (HashSet&lt;int&gt;::Enum e(s); !e.empty(); e.popFront())</span>
<a name="l00202"></a>00202 <span class="comment">         *     if (e.front() == 42)</span>
<a name="l00203"></a>00203 <span class="comment">         *       e.removeFront();</span>
<a name="l00204"></a>00204 <span class="comment">         */</span>
<a name="l00205"></a>00205         <span class="keywordtype">void</span> removeFront() {
<a name="l00206"></a>00206             table.remove(*this-&gt;cur);
<a name="l00207"></a>00207             removed = <span class="keyword">true</span>;
<a name="l00208"></a>00208             this-&gt;validEntry = <span class="keyword">false</span>;
<a name="l00209"></a>00209         }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211         <span class="comment">/*</span>
<a name="l00212"></a>00212 <span class="comment">         * Removes the |front()| element and re-inserts it into the table with</span>
<a name="l00213"></a>00213 <span class="comment">         * a new key at the new Lookup position.  |front()| is invalid after</span>
<a name="l00214"></a>00214 <span class="comment">         * this operation until the next call to |popFront()|.</span>
<a name="l00215"></a>00215 <span class="comment">         */</span>
<a name="l00216"></a>00216         <span class="keywordtype">void</span> rekeyFront(<span class="keyword">const</span> Lookup &amp;l, <span class="keyword">const</span> Key &amp;k) {
<a name="l00217"></a>00217             <span class="keyword">typename</span> HashTableEntry&lt;T&gt;::NonConstT t = this-&gt;cur-&gt;t;
<a name="l00218"></a>00218             HashPolicy::setKey(t, const_cast&lt;Key &amp;&gt;(k));
<a name="l00219"></a>00219             table.remove(*this-&gt;cur);
<a name="l00220"></a>00220             table.putNewInfallible(l, t);
<a name="l00221"></a>00221             rekeyed = <span class="keyword">true</span>;
<a name="l00222"></a>00222             this-&gt;validEntry = <span class="keyword">false</span>;
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         <span class="keywordtype">void</span> rekeyFront(<span class="keyword">const</span> Key &amp;k) {
<a name="l00226"></a>00226             rekeyFront(k, k);
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         <span class="comment">/* Potentially rehashes the table. */</span>
<a name="l00230"></a>00230         ~Enum() {
<a name="l00231"></a>00231             <span class="keywordflow">if</span> (rekeyed)
<a name="l00232"></a>00232                 table.checkOverRemoved();
<a name="l00233"></a>00233             <span class="keywordflow">if</span> (removed)
<a name="l00234"></a>00234                 table.checkUnderloaded();
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236     };
<a name="l00237"></a>00237 
<a name="l00238"></a>00238   <span class="keyword">private</span>:
<a name="l00239"></a>00239     uint32_t    hashShift;      <span class="comment">/* multiplicative hash shift */</span>
<a name="l00240"></a>00240     uint32_t    entryCount;     <span class="comment">/* number of entries in table */</span>
<a name="l00241"></a>00241     uint32_t    gen;            <span class="comment">/* entry storage generation number */</span>
<a name="l00242"></a>00242     uint32_t    removedCount;   <span class="comment">/* removed entry sentinels in table */</span>
<a name="l00243"></a>00243     Entry       *table;         <span class="comment">/* entry storage */</span>
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <span class="keywordtype">void</span> setTableSizeLog2(<span class="keywordtype">unsigned</span> sizeLog2) {
<a name="l00246"></a>00246         hashShift = sHashBits - sizeLog2;
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span>    <span class="keyword">mutable</span> <span class="keyword">struct </span>Stats {
<a name="l00251"></a>00251         uint32_t        searches;       <span class="comment">/* total number of table searches */</span>
<a name="l00252"></a>00252         uint32_t        steps;          <span class="comment">/* hash chain links traversed */</span>
<a name="l00253"></a>00253         uint32_t        hits;           <span class="comment">/* searches that found key */</span>
<a name="l00254"></a>00254         uint32_t        misses;         <span class="comment">/* searches that didn&#39;t find key */</span>
<a name="l00255"></a>00255         uint32_t        addOverRemoved; <span class="comment">/* adds that recycled a removed entry */</span>
<a name="l00256"></a>00256         uint32_t        removes;        <span class="comment">/* calls to remove */</span>
<a name="l00257"></a>00257         uint32_t        removeFrees;    <span class="comment">/* calls to remove that freed the entry */</span>
<a name="l00258"></a>00258         uint32_t        grows;          <span class="comment">/* table expansions */</span>
<a name="l00259"></a>00259         uint32_t        shrinks;        <span class="comment">/* table contractions */</span>
<a name="l00260"></a>00260         uint32_t        compresses;     <span class="comment">/* table compressions */</span>
<a name="l00261"></a>00261         uint32_t        rehashes;       <span class="comment">/* tombstone decontaminations */</span>
<a name="l00262"></a>00262     } stats;
<a name="l00263"></a>00263 <span class="preprocessor">#   define METER(x) x</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span><span class="preprocessor">#   define METER(x)</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span>
<a name="l00268"></a>00268     <span class="keyword">friend</span> <span class="keyword">class </span>js::ReentrancyGuard;
<a name="l00269"></a>00269     <span class="keyword">mutable</span> DebugOnly&lt;bool&gt; entered;
<a name="l00270"></a>00270     DebugOnly&lt;uint64_t&gt;     mutationCount;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272     <span class="comment">/* The default initial capacity is 16, but you can ask for as small as 4. */</span>
<a name="l00273"></a>00273     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> sMinSizeLog2  = 2;
<a name="l00274"></a>00274     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> sMinSize      = 1 &lt;&lt; sMinSizeLog2;
<a name="l00275"></a>00275     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> sDefaultInitSizeLog2 = 4;
<a name="l00276"></a>00276   <span class="keyword">public</span>:
<a name="l00277"></a>00277     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> sDefaultInitSize = 1 &lt;&lt; sDefaultInitSizeLog2;
<a name="l00278"></a>00278   <span class="keyword">private</span>:
<a name="l00279"></a>00279     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> sMaxInit      = JS_BIT(23);
<a name="l00280"></a>00280     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> sMaxCapacity  = JS_BIT(24);
<a name="l00281"></a>00281     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> sHashBits     = tl::BitSize&lt;HashNumber&gt;::result;
<a name="l00282"></a>00282     <span class="keyword">static</span> <span class="keyword">const</span> uint8_t  sMinAlphaFrac = 64;  <span class="comment">/* (0x100 * .25) taken from jsdhash.h */</span>
<a name="l00283"></a>00283     <span class="keyword">static</span> <span class="keyword">const</span> uint8_t  sMaxAlphaFrac = 192; <span class="comment">/* (0x100 * .75) taken from jsdhash.h */</span>
<a name="l00284"></a>00284     <span class="keyword">static</span> <span class="keyword">const</span> uint8_t  sInvMaxAlpha  = 171; <span class="comment">/* (ceil(0x100 / .75) &gt;&gt; 1) */</span>
<a name="l00285"></a>00285     <span class="keyword">static</span> <span class="keyword">const</span> HashNumber sFreeKey = Entry::sFreeKey;
<a name="l00286"></a>00286     <span class="keyword">static</span> <span class="keyword">const</span> HashNumber sRemovedKey = Entry::sRemovedKey;
<a name="l00287"></a>00287     <span class="keyword">static</span> <span class="keyword">const</span> HashNumber sCollisionBit = Entry::sCollisionBit;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="keyword">static</span> <span class="keywordtype">void</span> staticAsserts()
<a name="l00290"></a>00290     {
<a name="l00291"></a>00291         <span class="comment">/* Rely on compiler &quot;constant overflow warnings&quot;. */</span>
<a name="l00292"></a>00292         JS_STATIC_ASSERT(((sMaxInit * sInvMaxAlpha) &gt;&gt; 7) &lt; sMaxCapacity);
<a name="l00293"></a>00293         JS_STATIC_ASSERT((sMaxCapacity * sInvMaxAlpha) &lt;= UINT32_MAX);
<a name="l00294"></a>00294         JS_STATIC_ASSERT((sMaxCapacity * <span class="keyword">sizeof</span>(Entry)) &lt;= UINT32_MAX);
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="keyword">static</span> <span class="keywordtype">bool</span> isLiveHash(HashNumber hash)
<a name="l00298"></a>00298     {
<a name="l00299"></a>00299         <span class="keywordflow">return</span> Entry::isLiveHash(hash);
<a name="l00300"></a>00300     }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     <span class="keyword">static</span> HashNumber prepareHash(<span class="keyword">const</span> Lookup&amp; l)
<a name="l00303"></a>00303     {
<a name="l00304"></a>00304         HashNumber keyHash = ScrambleHashCode(HashPolicy::hash(l));
<a name="l00305"></a>00305 
<a name="l00306"></a>00306         <span class="comment">/* Avoid reserved hash codes. */</span>
<a name="l00307"></a>00307         <span class="keywordflow">if</span> (!isLiveHash(keyHash))
<a name="l00308"></a>00308             keyHash -= (sRemovedKey + 1);
<a name="l00309"></a>00309         <span class="keywordflow">return</span> keyHash &amp; ~sCollisionBit;
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="keyword">static</span> Entry *createTable(<a class="code" href="class_alloc_policy.html">AllocPolicy</a> &amp;alloc, uint32_t capacity)
<a name="l00313"></a>00313     {
<a name="l00314"></a>00314         Entry *newTable = (Entry *)alloc.malloc_(capacity * <span class="keyword">sizeof</span>(Entry));
<a name="l00315"></a>00315         <span class="keywordflow">if</span> (!newTable)
<a name="l00316"></a>00316             <span class="keywordflow">return</span> NULL;
<a name="l00317"></a>00317         <span class="keywordflow">for</span> (Entry *e = newTable, *end = e + capacity; e &lt; end; ++e)
<a name="l00318"></a>00318             <span class="keyword">new</span>(e) Entry();
<a name="l00319"></a>00319         <span class="keywordflow">return</span> newTable;
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     <span class="keyword">static</span> <span class="keywordtype">void</span> destroyTable(<a class="code" href="class_alloc_policy.html">AllocPolicy</a> &amp;alloc, Entry *oldTable, uint32_t capacity)
<a name="l00323"></a>00323     {
<a name="l00324"></a>00324         <span class="keywordflow">for</span> (Entry *e = oldTable, *end = e + capacity; e &lt; end; ++e)
<a name="l00325"></a>00325             e-&gt;~Entry();
<a name="l00326"></a>00326         alloc.free_(oldTable);
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329   <span class="keyword">public</span>:
<a name="l00330"></a>00330     HashTable(<a class="code" href="class_alloc_policy.html">AllocPolicy</a> ap)
<a name="l00331"></a>00331       : <a class="code" href="class_alloc_policy.html">AllocPolicy</a>(ap),
<a name="l00332"></a>00332         hashShift(sHashBits),
<a name="l00333"></a>00333         entryCount(0),
<a name="l00334"></a>00334         gen(0),
<a name="l00335"></a>00335         removedCount(0),
<a name="l00336"></a>00336         table(NULL),
<a name="l00337"></a>00337         entered(false),
<a name="l00338"></a>00338         mutationCount(0)
<a name="l00339"></a>00339     {}
<a name="l00340"></a>00340 
<a name="l00341"></a>00341     MOZ_WARN_UNUSED_RESULT <span class="keywordtype">bool</span> init(uint32_t length)
<a name="l00342"></a>00342     {
<a name="l00343"></a>00343         <span class="comment">/* Make sure that init isn&#39;t called twice. */</span>
<a name="l00344"></a>00344         JS_ASSERT(table == NULL);
<a name="l00345"></a>00345 
<a name="l00346"></a>00346         <span class="comment">/*</span>
<a name="l00347"></a>00347 <span class="comment">         * Correct for sMaxAlphaFrac such that the table will not resize</span>
<a name="l00348"></a>00348 <span class="comment">         * when adding &#39;length&#39; entries.</span>
<a name="l00349"></a>00349 <span class="comment">         */</span>
<a name="l00350"></a>00350         <span class="keywordflow">if</span> (length &gt; sMaxInit) {
<a name="l00351"></a>00351             this-&gt;reportAllocOverflow();
<a name="l00352"></a>00352             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00353"></a>00353         }
<a name="l00354"></a>00354         uint32_t capacity = (length * sInvMaxAlpha) &gt;&gt; 7;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         <span class="keywordflow">if</span> (capacity &lt; sMinSize)
<a name="l00357"></a>00357             capacity = sMinSize;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359         <span class="comment">/* FIXME: use JS_CEILING_LOG2 when PGO stops crashing (bug 543034). */</span>
<a name="l00360"></a>00360         uint32_t roundUp = sMinSize, roundUpLog2 = sMinSizeLog2;
<a name="l00361"></a>00361         <span class="keywordflow">while</span> (roundUp &lt; capacity) {
<a name="l00362"></a>00362             roundUp &lt;&lt;= 1;
<a name="l00363"></a>00363             ++roundUpLog2;
<a name="l00364"></a>00364         }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         capacity = roundUp;
<a name="l00367"></a>00367         JS_ASSERT(capacity &lt;= sMaxCapacity);
<a name="l00368"></a>00368 
<a name="l00369"></a>00369         table = createTable(*<span class="keyword">this</span>, capacity);
<a name="l00370"></a>00370         <span class="keywordflow">if</span> (!table)
<a name="l00371"></a>00371             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373         setTableSizeLog2(roundUpLog2);
<a name="l00374"></a>00374         METER(memset(&amp;stats, 0, <span class="keyword">sizeof</span>(stats)));
<a name="l00375"></a>00375         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00376"></a>00376     }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     <span class="keywordtype">bool</span> initialized()<span class="keyword"> const</span>
<a name="l00379"></a>00379 <span class="keyword">    </span>{
<a name="l00380"></a>00380         <span class="keywordflow">return</span> !!table;
<a name="l00381"></a>00381     }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383     ~HashTable()
<a name="l00384"></a>00384     {
<a name="l00385"></a>00385         <span class="keywordflow">if</span> (table)
<a name="l00386"></a>00386             destroyTable(*<span class="keyword">this</span>, table, capacity());
<a name="l00387"></a>00387     }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   <span class="keyword">private</span>:
<a name="l00390"></a>00390     <span class="keyword">static</span> HashNumber hash1(HashNumber hash0, uint32_t shift) {
<a name="l00391"></a>00391         <span class="keywordflow">return</span> hash0 &gt;&gt; shift;
<a name="l00392"></a>00392     }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394     <span class="keyword">struct </span>DoubleHash {
<a name="l00395"></a>00395         HashNumber h2;
<a name="l00396"></a>00396         HashNumber sizeMask;
<a name="l00397"></a>00397     };
<a name="l00398"></a>00398 
<a name="l00399"></a>00399     DoubleHash hash2(HashNumber curKeyHash, uint32_t hashShift)<span class="keyword"> const </span>{
<a name="l00400"></a>00400         <span class="keywordtype">unsigned</span> sizeLog2 = sHashBits - hashShift;
<a name="l00401"></a>00401         DoubleHash dh = {
<a name="l00402"></a>00402             ((curKeyHash &lt;&lt; sizeLog2) &gt;&gt; hashShift) | 1,
<a name="l00403"></a>00403             (HashNumber(1) &lt;&lt; sizeLog2) - 1
<a name="l00404"></a>00404         };
<a name="l00405"></a>00405         <span class="keywordflow">return</span> dh;
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408     <span class="keyword">static</span> HashNumber applyDoubleHash(HashNumber h1, <span class="keyword">const</span> DoubleHash &amp;dh) {
<a name="l00409"></a>00409         <span class="keywordflow">return</span> (h1 - dh.h2) &amp; dh.sizeMask;
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412     <span class="keywordtype">bool</span> overloaded() {
<a name="l00413"></a>00413         <span class="keywordflow">return</span> entryCount + removedCount &gt;= ((sMaxAlphaFrac * capacity()) &gt;&gt; 8);
<a name="l00414"></a>00414     }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     <span class="keywordtype">bool</span> underloaded() {
<a name="l00417"></a>00417         uint32_t tableCapacity = capacity();
<a name="l00418"></a>00418         <span class="keywordflow">return</span> tableCapacity &gt; sMinSize &amp;&amp;
<a name="l00419"></a>00419                entryCount &lt;= ((sMinAlphaFrac * tableCapacity) &gt;&gt; 8);
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422     <span class="keyword">static</span> <span class="keywordtype">bool</span> match(Entry &amp;e, <span class="keyword">const</span> Lookup &amp;l) {
<a name="l00423"></a>00423         <span class="keywordflow">return</span> HashPolicy::match(HashPolicy::getKey(e.t), l);
<a name="l00424"></a>00424     }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426     Entry &amp;lookup(<span class="keyword">const</span> Lookup &amp;l, HashNumber keyHash, <span class="keywordtype">unsigned</span> collisionBit)<span class="keyword"> const</span>
<a name="l00427"></a>00427 <span class="keyword">    </span>{
<a name="l00428"></a>00428         JS_ASSERT(isLiveHash(keyHash));
<a name="l00429"></a>00429         JS_ASSERT(!(keyHash &amp; sCollisionBit));
<a name="l00430"></a>00430         JS_ASSERT(collisionBit == 0 || collisionBit == sCollisionBit);
<a name="l00431"></a>00431         JS_ASSERT(table);
<a name="l00432"></a>00432         METER(stats.searches++);
<a name="l00433"></a>00433 
<a name="l00434"></a>00434         <span class="comment">/* Compute the primary hash address. */</span>
<a name="l00435"></a>00435         HashNumber h1 = hash1(keyHash, hashShift);
<a name="l00436"></a>00436         Entry *entry = &amp;table[h1];
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         <span class="comment">/* Miss: return space for a new entry. */</span>
<a name="l00439"></a>00439         <span class="keywordflow">if</span> (entry-&gt;isFree()) {
<a name="l00440"></a>00440             METER(stats.misses++);
<a name="l00441"></a>00441             <span class="keywordflow">return</span> *entry;
<a name="l00442"></a>00442         }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444         <span class="comment">/* Hit: return entry. */</span>
<a name="l00445"></a>00445         <span class="keywordflow">if</span> (entry-&gt;matchHash(keyHash) &amp;&amp; match(*entry, l)) {
<a name="l00446"></a>00446             METER(stats.hits++);
<a name="l00447"></a>00447             <span class="keywordflow">return</span> *entry;
<a name="l00448"></a>00448         }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450         <span class="comment">/* Collision: double hash. */</span>
<a name="l00451"></a>00451         DoubleHash dh = hash2(keyHash, hashShift);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         <span class="comment">/* Save the first removed entry pointer so we can recycle later. */</span>
<a name="l00454"></a>00454         Entry *firstRemoved = NULL;
<a name="l00455"></a>00455 
<a name="l00456"></a>00456         <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00457"></a>00457             <span class="keywordflow">if</span> (JS_UNLIKELY(entry-&gt;isRemoved())) {
<a name="l00458"></a>00458                 <span class="keywordflow">if</span> (!firstRemoved)
<a name="l00459"></a>00459                     firstRemoved = entry;
<a name="l00460"></a>00460             } <span class="keywordflow">else</span> {
<a name="l00461"></a>00461                 entry-&gt;setCollision(collisionBit);
<a name="l00462"></a>00462             }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464             METER(stats.steps++);
<a name="l00465"></a>00465             h1 = applyDoubleHash(h1, dh);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467             entry = &amp;table[h1];
<a name="l00468"></a>00468             <span class="keywordflow">if</span> (entry-&gt;isFree()) {
<a name="l00469"></a>00469                 METER(stats.misses++);
<a name="l00470"></a>00470                 <span class="keywordflow">return</span> firstRemoved ? *firstRemoved : *entry;
<a name="l00471"></a>00471             }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473             <span class="keywordflow">if</span> (entry-&gt;matchHash(keyHash) &amp;&amp; match(*entry, l)) {
<a name="l00474"></a>00474                 METER(stats.hits++);
<a name="l00475"></a>00475                 <span class="keywordflow">return</span> *entry;
<a name="l00476"></a>00476             }
<a name="l00477"></a>00477         }
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480     <span class="comment">/*</span>
<a name="l00481"></a>00481 <span class="comment">     * This is a copy of lookup hardcoded to the assumptions:</span>
<a name="l00482"></a>00482 <span class="comment">     *   1. the lookup is a lookupForAdd</span>
<a name="l00483"></a>00483 <span class="comment">     *   2. the key, whose |keyHash| has been passed is not in the table,</span>
<a name="l00484"></a>00484 <span class="comment">     *   3. no entries have been removed from the table.</span>
<a name="l00485"></a>00485 <span class="comment">     * This specialized search avoids the need for recovering lookup values</span>
<a name="l00486"></a>00486 <span class="comment">     * from entries, which allows more flexible Lookup/Key types.</span>
<a name="l00487"></a>00487 <span class="comment">     */</span>
<a name="l00488"></a>00488     Entry &amp;findFreeEntry(HashNumber keyHash)
<a name="l00489"></a>00489     {
<a name="l00490"></a>00490         JS_ASSERT(!(keyHash &amp; sCollisionBit));
<a name="l00491"></a>00491         JS_ASSERT(table);
<a name="l00492"></a>00492         METER(stats.searches++);
<a name="l00493"></a>00493 
<a name="l00494"></a>00494         <span class="comment">/* N.B. the |keyHash| has already been distributed. */</span>
<a name="l00495"></a>00495 
<a name="l00496"></a>00496         <span class="comment">/* Compute the primary hash address. */</span>
<a name="l00497"></a>00497         HashNumber h1 = hash1(keyHash, hashShift);
<a name="l00498"></a>00498         Entry *entry = &amp;table[h1];
<a name="l00499"></a>00499 
<a name="l00500"></a>00500         <span class="comment">/* Miss: return space for a new entry. */</span>
<a name="l00501"></a>00501         <span class="keywordflow">if</span> (!entry-&gt;isLive()) {
<a name="l00502"></a>00502             METER(stats.misses++);
<a name="l00503"></a>00503             <span class="keywordflow">return</span> *entry;
<a name="l00504"></a>00504         }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506         <span class="comment">/* Collision: double hash. */</span>
<a name="l00507"></a>00507         DoubleHash dh = hash2(keyHash, hashShift);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509         <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00510"></a>00510             JS_ASSERT(!entry-&gt;isRemoved());
<a name="l00511"></a>00511             entry-&gt;setCollision();
<a name="l00512"></a>00512 
<a name="l00513"></a>00513             METER(stats.steps++);
<a name="l00514"></a>00514             h1 = applyDoubleHash(h1, dh);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516             entry = &amp;table[h1];
<a name="l00517"></a>00517             <span class="keywordflow">if</span> (!entry-&gt;isLive()) {
<a name="l00518"></a>00518                 METER(stats.misses++);
<a name="l00519"></a>00519                 <span class="keywordflow">return</span> *entry;
<a name="l00520"></a>00520             }
<a name="l00521"></a>00521         }
<a name="l00522"></a>00522     }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524     <span class="keyword">enum</span> RebuildStatus { NotOverloaded, Rehashed, RehashFailed };
<a name="l00525"></a>00525 
<a name="l00526"></a>00526     RebuildStatus changeTableSize(<span class="keywordtype">int</span> deltaLog2)
<a name="l00527"></a>00527     {
<a name="l00528"></a>00528         <span class="comment">/* Look, but don&#39;t touch, until we succeed in getting new entry store. */</span>
<a name="l00529"></a>00529         Entry *oldTable = table;
<a name="l00530"></a>00530         uint32_t oldCap = capacity();
<a name="l00531"></a>00531         uint32_t newLog2 = sHashBits - hashShift + deltaLog2;
<a name="l00532"></a>00532         uint32_t newCapacity = JS_BIT(newLog2);
<a name="l00533"></a>00533         <span class="keywordflow">if</span> (newCapacity &gt; sMaxCapacity) {
<a name="l00534"></a>00534             this-&gt;reportAllocOverflow();
<a name="l00535"></a>00535             <span class="keywordflow">return</span> RehashFailed;
<a name="l00536"></a>00536         }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538         Entry *newTable = createTable(*<span class="keyword">this</span>, newCapacity);
<a name="l00539"></a>00539         <span class="keywordflow">if</span> (!newTable)
<a name="l00540"></a>00540             <span class="keywordflow">return</span> RehashFailed;
<a name="l00541"></a>00541 
<a name="l00542"></a>00542         <span class="comment">/* We can&#39;t fail from here on, so update table parameters. */</span>
<a name="l00543"></a>00543         setTableSizeLog2(newLog2);
<a name="l00544"></a>00544         removedCount = 0;
<a name="l00545"></a>00545         gen++;
<a name="l00546"></a>00546         table = newTable;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548         <span class="comment">/* Copy only live entries, leaving removed ones behind. */</span>
<a name="l00549"></a>00549         <span class="keywordflow">for</span> (Entry *src = oldTable, *end = src + oldCap; src &lt; end; ++src) {
<a name="l00550"></a>00550             <span class="keywordflow">if</span> (src-&gt;isLive()) {
<a name="l00551"></a>00551                 src-&gt;unsetCollision();
<a name="l00552"></a>00552                 findFreeEntry(src-&gt;getKeyHash()) = Move(*src);
<a name="l00553"></a>00553             }
<a name="l00554"></a>00554         }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556         destroyTable(*<span class="keyword">this</span>, oldTable, oldCap);
<a name="l00557"></a>00557         <span class="keywordflow">return</span> Rehashed;
<a name="l00558"></a>00558     }
<a name="l00559"></a>00559 
<a name="l00560"></a>00560     RebuildStatus checkOverloaded()
<a name="l00561"></a>00561     {
<a name="l00562"></a>00562         <span class="keywordflow">if</span> (!overloaded())
<a name="l00563"></a>00563             <span class="keywordflow">return</span> NotOverloaded;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565         <span class="comment">/* Compress if a quarter or more of all entries are removed. */</span>
<a name="l00566"></a>00566         <span class="keywordtype">int</span> deltaLog2;
<a name="l00567"></a>00567         <span class="keywordflow">if</span> (removedCount &gt;= (capacity() &gt;&gt; 2)) {
<a name="l00568"></a>00568             METER(stats.compresses++);
<a name="l00569"></a>00569             deltaLog2 = 0;
<a name="l00570"></a>00570         } <span class="keywordflow">else</span> {
<a name="l00571"></a>00571             METER(stats.grows++);
<a name="l00572"></a>00572             deltaLog2 = 1;
<a name="l00573"></a>00573         }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         <span class="keywordflow">return</span> changeTableSize(deltaLog2);
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578     <span class="comment">/* Infallibly rehash the table if we are overloaded with removals. */</span>
<a name="l00579"></a>00579     <span class="keywordtype">void</span> checkOverRemoved()
<a name="l00580"></a>00580     {
<a name="l00581"></a>00581         <span class="keywordflow">if</span> (overloaded()) {
<a name="l00582"></a>00582             METER(stats.rehashes++);
<a name="l00583"></a>00583             rehashTable();
<a name="l00584"></a>00584             JS_ASSERT(!overloaded());
<a name="l00585"></a>00585         }
<a name="l00586"></a>00586     }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588     <span class="keywordtype">void</span> <span class="keyword">remove</span>(Entry &amp;e)
<a name="l00589"></a>00589     {
<a name="l00590"></a>00590         JS_ASSERT(table);
<a name="l00591"></a>00591         METER(stats.removes++);
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         <span class="keywordflow">if</span> (e.hasCollision()) {
<a name="l00594"></a>00594             e.setRemoved();
<a name="l00595"></a>00595             removedCount++;
<a name="l00596"></a>00596         } <span class="keywordflow">else</span> {
<a name="l00597"></a>00597             METER(stats.removeFrees++);
<a name="l00598"></a>00598             e.setFree();
<a name="l00599"></a>00599         }
<a name="l00600"></a>00600         entryCount--;
<a name="l00601"></a>00601         mutationCount++;
<a name="l00602"></a>00602     }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="keywordtype">void</span> checkUnderloaded()
<a name="l00605"></a>00605     {
<a name="l00606"></a>00606         <span class="keywordflow">if</span> (underloaded()) {
<a name="l00607"></a>00607             METER(stats.shrinks++);
<a name="l00608"></a>00608             (void) changeTableSize(-1);
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     <span class="comment">/*</span>
<a name="l00613"></a>00613 <span class="comment">     * This is identical to changeTableSize(currentSize), but without requiring</span>
<a name="l00614"></a>00614 <span class="comment">     * a second table.  We do this by recycling the collision bits to tell us if</span>
<a name="l00615"></a>00615 <span class="comment">     * the element is already inserted or still waiting to be inserted.  Since</span>
<a name="l00616"></a>00616 <span class="comment">     * already-inserted elements win any conflicts, we get the same table as we</span>
<a name="l00617"></a>00617 <span class="comment">     * would have gotten through random insertion order.</span>
<a name="l00618"></a>00618 <span class="comment">     */</span>
<a name="l00619"></a>00619     <span class="keywordtype">void</span> rehashTable()
<a name="l00620"></a>00620     {
<a name="l00621"></a>00621         removedCount = 0;
<a name="l00622"></a>00622         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; capacity(); ++i)
<a name="l00623"></a>00623             table[i].unsetCollision();
<a name="l00624"></a>00624 
<a name="l00625"></a>00625         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; capacity();) {
<a name="l00626"></a>00626             Entry *src = &amp;table[i];
<a name="l00627"></a>00627 
<a name="l00628"></a>00628             <span class="keywordflow">if</span> (!src-&gt;isLive() || src-&gt;hasCollision()) {
<a name="l00629"></a>00629                 ++i;
<a name="l00630"></a>00630                 <span class="keywordflow">continue</span>;
<a name="l00631"></a>00631             }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633             HashNumber keyHash = src-&gt;getKeyHash();
<a name="l00634"></a>00634             HashNumber h1 = hash1(keyHash, hashShift);
<a name="l00635"></a>00635             DoubleHash dh = hash2(keyHash, hashShift);
<a name="l00636"></a>00636             Entry *tgt = &amp;table[h1];
<a name="l00637"></a>00637             <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00638"></a>00638                 <span class="keywordflow">if</span> (!tgt-&gt;hasCollision()) {
<a name="l00639"></a>00639                     Swap(*src, *tgt);
<a name="l00640"></a>00640                     tgt-&gt;setCollision();
<a name="l00641"></a>00641                     <span class="keywordflow">break</span>;
<a name="l00642"></a>00642                 }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644                 h1 = applyDoubleHash(h1, dh);
<a name="l00645"></a>00645                 tgt = &amp;table[h1];
<a name="l00646"></a>00646             }
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         <span class="comment">/*</span>
<a name="l00650"></a>00650 <span class="comment">         * TODO: this algorithm leaves collision bits on *all* elements, even if</span>
<a name="l00651"></a>00651 <span class="comment">         * they are on no collision path. We have the option of setting the</span>
<a name="l00652"></a>00652 <span class="comment">         * collision bits correctly on a subsequent pass or skipping the rehash</span>
<a name="l00653"></a>00653 <span class="comment">         * unless we are totally filled with tombstones: benchmark to find out</span>
<a name="l00654"></a>00654 <span class="comment">         * which approach is best.</span>
<a name="l00655"></a>00655 <span class="comment">         */</span>
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   <span class="keyword">public</span>:
<a name="l00659"></a>00659     <span class="keywordtype">void</span> clear()
<a name="l00660"></a>00660     {
<a name="l00661"></a>00661         <span class="keywordflow">if</span> (tl::IsPodType&lt;Entry&gt;::result) {
<a name="l00662"></a>00662             memset(table, 0, <span class="keyword">sizeof</span>(*table) * capacity());
<a name="l00663"></a>00663         } <span class="keywordflow">else</span> {
<a name="l00664"></a>00664             uint32_t tableCapacity = capacity();
<a name="l00665"></a>00665             <span class="keywordflow">for</span> (Entry *e = table, *end = table + tableCapacity; e &lt; end; ++e)
<a name="l00666"></a>00666                 *e = Move(Entry());
<a name="l00667"></a>00667         }
<a name="l00668"></a>00668         removedCount = 0;
<a name="l00669"></a>00669         entryCount = 0;
<a name="l00670"></a>00670         mutationCount++;
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673     <span class="keywordtype">void</span> finish()
<a name="l00674"></a>00674     {
<a name="l00675"></a>00675         JS_ASSERT(!entered);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677         <span class="keywordflow">if</span> (!table)
<a name="l00678"></a>00678             <span class="keywordflow">return</span>;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680         destroyTable(*<span class="keyword">this</span>, table, capacity());
<a name="l00681"></a>00681         table = NULL;
<a name="l00682"></a>00682         gen++;
<a name="l00683"></a>00683         entryCount = 0;
<a name="l00684"></a>00684         removedCount = 0;
<a name="l00685"></a>00685         mutationCount++;
<a name="l00686"></a>00686     }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688     Range all()<span class="keyword"> const </span>{
<a name="l00689"></a>00689         JS_ASSERT(table);
<a name="l00690"></a>00690         <span class="keywordflow">return</span> Range(table, table + capacity());
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693     <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{
<a name="l00694"></a>00694         JS_ASSERT(table);
<a name="l00695"></a>00695         <span class="keywordflow">return</span> !entryCount;
<a name="l00696"></a>00696     }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     uint32_t count()<span class="keyword"> const </span>{
<a name="l00699"></a>00699         JS_ASSERT(table);
<a name="l00700"></a>00700         <span class="keywordflow">return</span> entryCount;
<a name="l00701"></a>00701     }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     uint32_t capacity()<span class="keyword"> const </span>{
<a name="l00704"></a>00704         JS_ASSERT(table);
<a name="l00705"></a>00705         <span class="keywordflow">return</span> JS_BIT(sHashBits - hashShift);
<a name="l00706"></a>00706     }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708     uint32_t generation()<span class="keyword"> const </span>{
<a name="l00709"></a>00709         JS_ASSERT(table);
<a name="l00710"></a>00710         <span class="keywordflow">return</span> gen;
<a name="l00711"></a>00711     }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713     <span class="keywordtype">size_t</span> sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf)<span class="keyword"> const </span>{
<a name="l00714"></a>00714         <span class="keywordflow">return</span> mallocSizeOf(table);
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717     <span class="keywordtype">size_t</span> sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf)<span class="keyword"> const </span>{
<a name="l00718"></a>00718         <span class="keywordflow">return</span> mallocSizeOf(<span class="keyword">this</span>) + sizeOfExcludingThis(mallocSizeOf);
<a name="l00719"></a>00719     }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721     Ptr lookup(<span class="keyword">const</span> Lookup &amp;l)<span class="keyword"> const </span>{
<a name="l00722"></a>00722         ReentrancyGuard g(*<span class="keyword">this</span>);
<a name="l00723"></a>00723         HashNumber keyHash = prepareHash(l);
<a name="l00724"></a>00724         <span class="keywordflow">return</span> Ptr(lookup(l, keyHash, 0));
<a name="l00725"></a>00725     }
<a name="l00726"></a>00726 
<a name="l00727"></a>00727     AddPtr lookupForAdd(<span class="keyword">const</span> Lookup &amp;l)<span class="keyword"> const </span>{
<a name="l00728"></a>00728         ReentrancyGuard g(*<span class="keyword">this</span>);
<a name="l00729"></a>00729         HashNumber keyHash = prepareHash(l);
<a name="l00730"></a>00730         Entry &amp;entry = lookup(l, keyHash, sCollisionBit);
<a name="l00731"></a>00731         AddPtr p(entry, keyHash);
<a name="l00732"></a>00732         p.mutationCount = mutationCount;
<a name="l00733"></a>00733         <span class="keywordflow">return</span> p;
<a name="l00734"></a>00734     }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     <span class="keywordtype">bool</span> add(AddPtr &amp;p)
<a name="l00737"></a>00737     {
<a name="l00738"></a>00738         ReentrancyGuard g(*<span class="keyword">this</span>);
<a name="l00739"></a>00739         JS_ASSERT(mutationCount == p.mutationCount);
<a name="l00740"></a>00740         JS_ASSERT(table);
<a name="l00741"></a>00741         JS_ASSERT(!p.found());
<a name="l00742"></a>00742         JS_ASSERT(!(p.keyHash &amp; sCollisionBit));
<a name="l00743"></a>00743 
<a name="l00744"></a>00744         <span class="comment">/*</span>
<a name="l00745"></a>00745 <span class="comment">         * Changing an entry from removed to live does not affect whether we</span>
<a name="l00746"></a>00746 <span class="comment">         * are overloaded and can be handled separately.</span>
<a name="l00747"></a>00747 <span class="comment">         */</span>
<a name="l00748"></a>00748         <span class="keywordflow">if</span> (p.entry-&gt;isRemoved()) {
<a name="l00749"></a>00749             METER(stats.addOverRemoved++);
<a name="l00750"></a>00750             removedCount--;
<a name="l00751"></a>00751             p.keyHash |= sCollisionBit;
<a name="l00752"></a>00752         } <span class="keywordflow">else</span> {
<a name="l00753"></a>00753             <span class="comment">/* Preserve the validity of |p.entry|. */</span>
<a name="l00754"></a>00754             RebuildStatus status = checkOverloaded();
<a name="l00755"></a>00755             <span class="keywordflow">if</span> (status == RehashFailed)
<a name="l00756"></a>00756                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00757"></a>00757             <span class="keywordflow">if</span> (status == Rehashed)
<a name="l00758"></a>00758                 p.entry = &amp;findFreeEntry(p.keyHash);
<a name="l00759"></a>00759         }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761         p.entry-&gt;setLive(p.keyHash);
<a name="l00762"></a>00762         entryCount++;
<a name="l00763"></a>00763         mutationCount++;
<a name="l00764"></a>00764         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00765"></a>00765     }
<a name="l00766"></a>00766 
<a name="l00767"></a>00767     <span class="comment">/*</span>
<a name="l00768"></a>00768 <span class="comment">     * There is an important contract between the caller and callee for this</span>
<a name="l00769"></a>00769 <span class="comment">     * function: if add() returns true, the caller must assign the T value</span>
<a name="l00770"></a>00770 <span class="comment">     * which produced p before using the hashtable again.</span>
<a name="l00771"></a>00771 <span class="comment">     */</span>
<a name="l00772"></a>00772     <span class="keywordtype">bool</span> add(AddPtr &amp;p, T** pentry)
<a name="l00773"></a>00773     {
<a name="l00774"></a>00774         <span class="keywordflow">if</span> (!add(p))
<a name="l00775"></a>00775             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00776"></a>00776         *pentry = &amp;p.entry-&gt;t;
<a name="l00777"></a>00777         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00778"></a>00778     }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780     <span class="keywordtype">bool</span> add(AddPtr &amp;p, <span class="keyword">const</span> T &amp;t)
<a name="l00781"></a>00781     {
<a name="l00782"></a>00782         <span class="keywordflow">if</span> (!add(p))
<a name="l00783"></a>00783             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00784"></a>00784         p.entry-&gt;t = t;
<a name="l00785"></a>00785         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00786"></a>00786     }
<a name="l00787"></a>00787 
<a name="l00788"></a>00788     <span class="keywordtype">void</span> putNewInfallible(<span class="keyword">const</span> Lookup &amp;l, <span class="keyword">const</span> T &amp;t)
<a name="l00789"></a>00789     {
<a name="l00790"></a>00790         JS_ASSERT(table);
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         HashNumber keyHash = prepareHash(l);
<a name="l00793"></a>00793         Entry *entry = &amp;findFreeEntry(keyHash);
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         <span class="keywordflow">if</span> (entry-&gt;isRemoved()) {
<a name="l00796"></a>00796             METER(stats.addOverRemoved++);
<a name="l00797"></a>00797             removedCount--;
<a name="l00798"></a>00798             keyHash |= sCollisionBit;
<a name="l00799"></a>00799         }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         entry-&gt;t = t;
<a name="l00802"></a>00802         entry-&gt;setLive(keyHash);
<a name="l00803"></a>00803         entryCount++;
<a name="l00804"></a>00804         mutationCount++;
<a name="l00805"></a>00805     }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807     <span class="keywordtype">bool</span> putNew(<span class="keyword">const</span> Lookup &amp;l, <span class="keyword">const</span> T &amp;t)
<a name="l00808"></a>00808     {
<a name="l00809"></a>00809         <span class="keywordflow">if</span> (checkOverloaded() == RehashFailed)
<a name="l00810"></a>00810             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812         putNewInfallible(l, t);
<a name="l00813"></a>00813         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00814"></a>00814     }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816     <span class="keywordtype">bool</span> relookupOrAdd(AddPtr&amp; p, <span class="keyword">const</span> Lookup &amp;l, <span class="keyword">const</span> T&amp; t)
<a name="l00817"></a>00817     {
<a name="l00818"></a>00818         p.mutationCount = mutationCount;
<a name="l00819"></a>00819         {
<a name="l00820"></a>00820             ReentrancyGuard g(*<span class="keyword">this</span>);
<a name="l00821"></a>00821             p.entry = &amp;lookup(l, p.keyHash, sCollisionBit);
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823         <span class="keywordflow">return</span> p.found() || add(p, t);
<a name="l00824"></a>00824     }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826     <span class="keywordtype">void</span> <span class="keyword">remove</span>(Ptr p)
<a name="l00827"></a>00827     {
<a name="l00828"></a>00828         JS_ASSERT(table);
<a name="l00829"></a>00829         ReentrancyGuard g(*<span class="keyword">this</span>);
<a name="l00830"></a>00830         JS_ASSERT(p.found());
<a name="l00831"></a>00831         <span class="keyword">remove</span>(*p.entry);
<a name="l00832"></a>00832         checkUnderloaded();
<a name="l00833"></a>00833     }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 <span class="preprocessor">#undef METER</span>
<a name="l00836"></a>00836 <span class="preprocessor"></span>};
<a name="l00837"></a>00837 
<a name="l00838"></a>00838 }  <span class="comment">/* namespace detail */</span>
<a name="l00839"></a>00839 
<a name="l00840"></a>00840 <span class="comment">/*****************************************************************************/</span>
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 <span class="comment">/*</span>
<a name="l00843"></a>00843 <span class="comment"> * Hash policy</span>
<a name="l00844"></a>00844 <span class="comment"> *</span>
<a name="l00845"></a>00845 <span class="comment"> * A hash policy P for a hash table with key-type Key must provide:</span>
<a name="l00846"></a>00846 <span class="comment"> *  - a type |P::Lookup| to use to lookup table entries;</span>
<a name="l00847"></a>00847 <span class="comment"> *  - a static member function |P::hash| with signature</span>
<a name="l00848"></a>00848 <span class="comment"> *</span>
<a name="l00849"></a>00849 <span class="comment"> *      static js::HashNumber hash(Lookup)</span>
<a name="l00850"></a>00850 <span class="comment"> *</span>
<a name="l00851"></a>00851 <span class="comment"> *    to use to hash the lookup type; and</span>
<a name="l00852"></a>00852 <span class="comment"> *  - a static member function |P::match| with signature</span>
<a name="l00853"></a>00853 <span class="comment"> *</span>
<a name="l00854"></a>00854 <span class="comment"> *      static bool match(Key, Lookup)</span>
<a name="l00855"></a>00855 <span class="comment"> *</span>
<a name="l00856"></a>00856 <span class="comment"> *    to use to test equality of key and lookup values.</span>
<a name="l00857"></a>00857 <span class="comment"> *</span>
<a name="l00858"></a>00858 <span class="comment"> * Normally, Lookup = Key. In general, though, different values and types of</span>
<a name="l00859"></a>00859 <span class="comment"> * values can be used to lookup and store. If a Lookup value |l| is != to the</span>
<a name="l00860"></a>00860 <span class="comment"> * added Key value |k|, the user must ensure that |P::match(k,l)|. E.g.:</span>
<a name="l00861"></a>00861 <span class="comment"> *</span>
<a name="l00862"></a>00862 <span class="comment"> *   js::HashSet&lt;Key, P&gt;::AddPtr p = h.lookup(l);</span>
<a name="l00863"></a>00863 <span class="comment"> *   if (!p) {</span>
<a name="l00864"></a>00864 <span class="comment"> *     assert(P::match(k, l));  // must hold</span>
<a name="l00865"></a>00865 <span class="comment"> *     h.add(p, k);</span>
<a name="l00866"></a>00866 <span class="comment"> *   }</span>
<a name="l00867"></a>00867 <span class="comment"> */</span>
<a name="l00868"></a>00868 
<a name="l00869"></a>00869 <span class="comment">/* Default hashing policies. */</span>
<a name="l00870"></a>00870 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key&gt;
<a name="l00871"></a>00871 <span class="keyword">struct </span>DefaultHasher
<a name="l00872"></a>00872 {
<a name="l00873"></a>00873     <span class="keyword">typedef</span> Key Lookup;
<a name="l00874"></a>00874     <span class="keyword">static</span> HashNumber hash(<span class="keyword">const</span> Lookup &amp;l) {
<a name="l00875"></a>00875         <span class="comment">/* Hash if can implicitly cast to hash number type. */</span>
<a name="l00876"></a>00876         <span class="keywordflow">return</span> l;
<a name="l00877"></a>00877     }
<a name="l00878"></a>00878     <span class="keyword">static</span> <span class="keywordtype">bool</span> match(<span class="keyword">const</span> Key &amp;k, <span class="keyword">const</span> Lookup &amp;l) {
<a name="l00879"></a>00879         <span class="comment">/* Use builtin or overloaded operator==. */</span>
<a name="l00880"></a>00880         <span class="keywordflow">return</span> k == l;
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882 };
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 <span class="comment">/*</span>
<a name="l00885"></a>00885 <span class="comment"> * Pointer hashing policy that strips the lowest zeroBits when calculating the</span>
<a name="l00886"></a>00886 <span class="comment"> * hash to improve key distribution.</span>
<a name="l00887"></a>00887 <span class="comment"> */</span>
<a name="l00888"></a>00888 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keywordtype">size_t</span> zeroBits&gt;
<a name="l00889"></a>00889 <span class="keyword">struct </span>PointerHasher
<a name="l00890"></a>00890 {
<a name="l00891"></a>00891     <span class="keyword">typedef</span> Key Lookup;
<a name="l00892"></a>00892     <span class="keyword">static</span> HashNumber hash(<span class="keyword">const</span> Lookup &amp;l) {
<a name="l00893"></a>00893         <span class="keywordtype">size_t</span> word = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(l) &gt;&gt; zeroBits;
<a name="l00894"></a>00894         JS_STATIC_ASSERT(<span class="keyword">sizeof</span>(HashNumber) == 4);
<a name="l00895"></a>00895 <span class="preprocessor">#if JS_BYTES_PER_WORD == 4</span>
<a name="l00896"></a>00896 <span class="preprocessor"></span>        <span class="keywordflow">return</span> HashNumber(word);
<a name="l00897"></a>00897 <span class="preprocessor">#else</span>
<a name="l00898"></a>00898 <span class="preprocessor"></span>        JS_STATIC_ASSERT(<span class="keyword">sizeof</span> word == 8);
<a name="l00899"></a>00899         <span class="keywordflow">return</span> HashNumber((word &gt;&gt; 32) ^ word);
<a name="l00900"></a>00900 <span class="preprocessor">#endif</span>
<a name="l00901"></a>00901 <span class="preprocessor"></span>    }
<a name="l00902"></a>00902     <span class="keyword">static</span> <span class="keywordtype">bool</span> match(<span class="keyword">const</span> Key &amp;k, <span class="keyword">const</span> Lookup &amp;l) {
<a name="l00903"></a>00903         <span class="keywordflow">return</span> k == l;
<a name="l00904"></a>00904     }
<a name="l00905"></a>00905 };
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keywordtype">size_t</span> zeroBits&gt;
<a name="l00908"></a>00908 <span class="keyword">struct </span>TaggedPointerHasher
<a name="l00909"></a>00909 {
<a name="l00910"></a>00910     <span class="keyword">typedef</span> Key Lookup;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912     <span class="keyword">static</span> HashNumber hash(<span class="keyword">const</span> Lookup &amp;l) {
<a name="l00913"></a>00913         <span class="keywordflow">return</span> PointerHasher&lt;Key, zeroBits&gt;::hash(l);
<a name="l00914"></a>00914     }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916     <span class="keyword">static</span> <span class="keyword">const</span> uintptr_t COMPARE_MASK = uintptr_t(-1) - 1;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918     <span class="keyword">static</span> <span class="keywordtype">bool</span> match(<span class="keyword">const</span> Key &amp;k, <span class="keyword">const</span> Lookup &amp;l) {
<a name="l00919"></a>00919         <span class="keywordflow">return</span> (uintptr_t(k) &amp; COMPARE_MASK) == uintptr_t(l);
<a name="l00920"></a>00920     }
<a name="l00921"></a>00921 };
<a name="l00922"></a>00922 
<a name="l00923"></a>00923 <span class="comment">/*</span>
<a name="l00924"></a>00924 <span class="comment"> * Specialized hashing policy for pointer types. It assumes that the type is</span>
<a name="l00925"></a>00925 <span class="comment"> * at least word-aligned. For types with smaller size use PointerHasher.</span>
<a name="l00926"></a>00926 <span class="comment"> */</span>
<a name="l00927"></a>00927 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00928"></a>00928 <span class="keyword">struct </span>DefaultHasher&lt;T *&gt;: PointerHasher&lt;T *, tl::FloorLog2&lt;sizeof(void *)&gt;::result&gt; { };
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 <span class="comment">/* Looking for a hasher for jsid?  Try the DefaultHasher&lt;jsid&gt; in jsatom.h. */</span>
<a name="l00931"></a>00931 
<a name="l00932"></a>00932 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> Value&gt;
<a name="l00933"></a>00933 <span class="keyword">class </span>HashMapEntry
<a name="l00934"></a>00934 {
<a name="l00935"></a>00935     <span class="keyword">template</span> &lt;<span class="keyword">class</span>, <span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">friend</span> <span class="keyword">class </span>detail::HashTable;
<a name="l00936"></a>00936     <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">friend</span> <span class="keyword">class </span>detail::HashTableEntry;
<a name="l00937"></a>00937     <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> HashMapEntry &amp;rhs) {
<a name="l00938"></a>00938         <span class="keyword">const_cast&lt;</span>Key &amp;<span class="keyword">&gt;</span>(key) = rhs.key;
<a name="l00939"></a>00939         value = rhs.value;
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <span class="keyword">public</span>:
<a name="l00943"></a>00943     HashMapEntry() : key(), value() {}
<a name="l00944"></a>00944 
<a name="l00945"></a>00945     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeyInput, <span class="keyword">typename</span> ValueInput&gt;
<a name="l00946"></a>00946     HashMapEntry(<span class="keyword">const</span> KeyInput &amp;k, <span class="keyword">const</span> ValueInput &amp;v) : key(k), value(v) {}
<a name="l00947"></a>00947 
<a name="l00948"></a>00948     HashMapEntry(MoveRef&lt;HashMapEntry&gt; rhs)
<a name="l00949"></a>00949       : key(Move(rhs-&gt;key)), value(Move(rhs-&gt;value)) { }
<a name="l00950"></a>00950     <span class="keywordtype">void</span> operator=(MoveRef&lt;HashMapEntry&gt; rhs) {
<a name="l00951"></a>00951         <span class="keyword">const_cast&lt;</span>Key &amp;<span class="keyword">&gt;</span>(key) = Move(rhs-&gt;key);
<a name="l00952"></a>00952         value = Move(rhs-&gt;value);
<a name="l00953"></a>00953     }
<a name="l00954"></a>00954 
<a name="l00955"></a>00955     <span class="keyword">const</span> Key key;
<a name="l00956"></a>00956     Value value;
<a name="l00957"></a>00957 };
<a name="l00958"></a>00958 
<a name="l00959"></a>00959 <span class="keyword">namespace </span>tl {
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00962"></a>00962 <span class="keyword">struct </span>IsPodType&lt;detail::HashTableEntry&lt;T&gt; &gt; {
<a name="l00963"></a>00963     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = IsPodType&lt;T&gt;::result;
<a name="l00964"></a>00964 };
<a name="l00965"></a>00965 
<a name="l00966"></a>00966 <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> V&gt;
<a name="l00967"></a>00967 <span class="keyword">struct </span>IsPodType&lt;HashMapEntry&lt;K, V&gt; &gt;
<a name="l00968"></a>00968 {
<a name="l00969"></a>00969     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> result = IsPodType&lt;K&gt;::result &amp;&amp; IsPodType&lt;V&gt;::result;
<a name="l00970"></a>00970 };
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 } <span class="comment">/* namespace tl */</span>
<a name="l00973"></a>00973 
<a name="l00974"></a>00974 <span class="comment">/*</span>
<a name="l00975"></a>00975 <span class="comment"> * JS-friendly, STL-like container providing a hash-based map from keys to</span>
<a name="l00976"></a>00976 <span class="comment"> * values. In particular, HashMap calls constructors and destructors of all</span>
<a name="l00977"></a>00977 <span class="comment"> * objects added so non-PODs may be used safely.</span>
<a name="l00978"></a>00978 <span class="comment"> *</span>
<a name="l00979"></a>00979 <span class="comment"> * Key/Value requirements:</span>
<a name="l00980"></a>00980 <span class="comment"> *  - default constructible, copyable, destructible, assignable</span>
<a name="l00981"></a>00981 <span class="comment"> * HashPolicy requirements:</span>
<a name="l00982"></a>00982 <span class="comment"> *  - see &quot;Hash policy&quot; above (default js::DefaultHasher&lt;Key&gt;)</span>
<a name="l00983"></a>00983 <span class="comment"> * AllocPolicy:</span>
<a name="l00984"></a>00984 <span class="comment"> *  - see &quot;Allocation policies&quot; in jsalloc.h</span>
<a name="l00985"></a>00985 <span class="comment"> *</span>
<a name="l00986"></a>00986 <span class="comment"> * N.B: HashMap is not reentrant: Key/Value/HashPolicy/AllocPolicy members</span>
<a name="l00987"></a>00987 <span class="comment"> *      called by HashMap must not call back into the same HashMap object.</span>
<a name="l00988"></a>00988 <span class="comment"> * N.B: Due to the lack of exception handling, the user must call |init()|.</span>
<a name="l00989"></a>00989 <span class="comment"> */</span>
<a name="l00990"></a>00990 <span class="keyword">template</span> &lt;<span class="keyword">class </span>Key,
<a name="l00991"></a>00991           <span class="keyword">class </span>Value,
<a name="l00992"></a>00992           <span class="keyword">class </span>HashPolicy = DefaultHasher&lt;Key&gt;,
<a name="l00993"></a>00993           <span class="keyword">class </span><a class="code" href="class_alloc_policy.html">AllocPolicy</a> = TempAllocPolicy&gt;
<a name="l00994"></a>00994 <span class="keyword">class </span>HashMap
<a name="l00995"></a>00995 {
<a name="l00996"></a>00996     <span class="keyword">typedef</span> <span class="keyword">typename</span> tl::StaticAssert&lt;tl::IsRelocatableHeapType&lt;Key&gt;::result&gt;::result keyAssert;
<a name="l00997"></a>00997     <span class="keyword">typedef</span> <span class="keyword">typename</span> tl::StaticAssert&lt;tl::IsRelocatableHeapType&lt;Value&gt;::result&gt;::result valAssert;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999   <span class="keyword">public</span>:
<a name="l01000"></a>01000     <span class="keyword">typedef</span> <span class="keyword">typename</span> HashPolicy::Lookup Lookup;
<a name="l01001"></a>01001 
<a name="l01002"></a>01002     <span class="keyword">typedef</span> HashMapEntry&lt;Key, Value&gt; Entry;
<a name="l01003"></a>01003 
<a name="l01004"></a>01004   <span class="keyword">private</span>:
<a name="l01005"></a>01005     <span class="comment">/* Implement HashMap using HashTable. Lift |Key| operations to |Entry|. */</span>
<a name="l01006"></a>01006     <span class="keyword">struct </span>MapHashPolicy : HashPolicy
<a name="l01007"></a>01007     {
<a name="l01008"></a>01008         <span class="keyword">typedef</span> Key KeyType;
<a name="l01009"></a>01009         <span class="keyword">static</span> <span class="keyword">const</span> Key &amp;getKey(Entry &amp;e) { <span class="keywordflow">return</span> e.key; }
<a name="l01010"></a>01010         <span class="keyword">static</span> <span class="keywordtype">void</span> setKey(Entry &amp;e, Key &amp;k) { <span class="keyword">const_cast&lt;</span>Key &amp;<span class="keyword">&gt;</span>(e.key) = k; }
<a name="l01011"></a>01011     };
<a name="l01012"></a>01012     <span class="keyword">typedef</span> detail::HashTable&lt;Entry, MapHashPolicy, AllocPolicy&gt; Impl;
<a name="l01013"></a>01013 
<a name="l01014"></a>01014     <span class="keyword">friend</span> <span class="keyword">class </span>Impl::Enum;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016     <span class="comment">/* Not implicitly copyable (expensive). May add explicit |clone| later. */</span>
<a name="l01017"></a>01017     HashMap(<span class="keyword">const</span> HashMap &amp;);
<a name="l01018"></a>01018     HashMap &amp;operator=(<span class="keyword">const</span> HashMap &amp;);
<a name="l01019"></a>01019 
<a name="l01020"></a>01020     Impl impl;
<a name="l01021"></a>01021 
<a name="l01022"></a>01022   <span class="keyword">public</span>:
<a name="l01023"></a>01023     <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> sDefaultInitSize = Impl::sDefaultInitSize;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025     <span class="comment">/*</span>
<a name="l01026"></a>01026 <span class="comment">     * HashMap construction is fallible (due to OOM); thus the user must call</span>
<a name="l01027"></a>01027 <span class="comment">     * init after constructing a HashMap and check the return value.</span>
<a name="l01028"></a>01028 <span class="comment">     */</span>
<a name="l01029"></a>01029     HashMap(<a class="code" href="class_alloc_policy.html">AllocPolicy</a> a = <a class="code" href="class_alloc_policy.html">AllocPolicy</a>()) : impl(a)  {}
<a name="l01030"></a>01030     <span class="keywordtype">bool</span> init(uint32_t len = sDefaultInitSize)        { <span class="keywordflow">return</span> impl.init(len); }
<a name="l01031"></a>01031     <span class="keywordtype">bool</span> initialized()<span class="keyword"> const                          </span>{ <span class="keywordflow">return</span> impl.initialized(); }
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="comment">/*</span>
<a name="l01034"></a>01034 <span class="comment">     * Return whether the given lookup value is present in the map. E.g.:</span>
<a name="l01035"></a>01035 <span class="comment">     *</span>
<a name="l01036"></a>01036 <span class="comment">     *   typedef HashMap&lt;int,char&gt; HM;</span>
<a name="l01037"></a>01037 <span class="comment">     *   HM h;</span>
<a name="l01038"></a>01038 <span class="comment">     *   if (HM::Ptr p = h.lookup(3)) {</span>
<a name="l01039"></a>01039 <span class="comment">     *     const HM::Entry &amp;e = *p; // p acts like a pointer to Entry</span>
<a name="l01040"></a>01040 <span class="comment">     *     assert(p-&gt;key == 3);     // Entry contains the key</span>
<a name="l01041"></a>01041 <span class="comment">     *     char val = p-&gt;value;     // and value</span>
<a name="l01042"></a>01042 <span class="comment">     *   }</span>
<a name="l01043"></a>01043 <span class="comment">     *</span>
<a name="l01044"></a>01044 <span class="comment">     * Also see the definition of Ptr in HashTable above (with T = Entry).</span>
<a name="l01045"></a>01045 <span class="comment">     */</span>
<a name="l01046"></a>01046     <span class="keyword">typedef</span> <span class="keyword">typename</span> Impl::Ptr Ptr;
<a name="l01047"></a>01047     Ptr lookup(<span class="keyword">const</span> Lookup &amp;l)<span class="keyword"> const                 </span>{ <span class="keywordflow">return</span> impl.lookup(l); }
<a name="l01048"></a>01048 
<a name="l01049"></a>01049     <span class="comment">/* Assuming |p.found()|, remove |*p|. */</span>
<a name="l01050"></a>01050     <span class="keywordtype">void</span> <span class="keyword">remove</span>(Ptr p)                                { impl.remove(p); }
<a name="l01051"></a>01051 
<a name="l01052"></a>01052     <span class="comment">/*</span>
<a name="l01053"></a>01053 <span class="comment">     * Like |lookup(l)|, but on miss, |p = lookupForAdd(l)| allows efficient</span>
<a name="l01054"></a>01054 <span class="comment">     * insertion of Key |k| (where |HashPolicy::match(k,l) == true|) using</span>
<a name="l01055"></a>01055 <span class="comment">     * |add(p,k,v)|. After |add(p,k,v)|, |p| points to the new Entry. E.g.:</span>
<a name="l01056"></a>01056 <span class="comment">     *</span>
<a name="l01057"></a>01057 <span class="comment">     *   typedef HashMap&lt;int,char&gt; HM;</span>
<a name="l01058"></a>01058 <span class="comment">     *   HM h;</span>
<a name="l01059"></a>01059 <span class="comment">     *   HM::AddPtr p = h.lookupForAdd(3);</span>
<a name="l01060"></a>01060 <span class="comment">     *   if (!p) {</span>
<a name="l01061"></a>01061 <span class="comment">     *     if (!h.add(p, 3, &#39;a&#39;))</span>
<a name="l01062"></a>01062 <span class="comment">     *       return false;</span>
<a name="l01063"></a>01063 <span class="comment">     *   }</span>
<a name="l01064"></a>01064 <span class="comment">     *   const HM::Entry &amp;e = *p;   // p acts like a pointer to Entry</span>
<a name="l01065"></a>01065 <span class="comment">     *   assert(p-&gt;key == 3);       // Entry contains the key</span>
<a name="l01066"></a>01066 <span class="comment">     *   char val = p-&gt;value;       // and value</span>
<a name="l01067"></a>01067 <span class="comment">     *</span>
<a name="l01068"></a>01068 <span class="comment">     * Also see the definition of AddPtr in HashTable above (with T = Entry).</span>
<a name="l01069"></a>01069 <span class="comment">     *</span>
<a name="l01070"></a>01070 <span class="comment">     * N.B. The caller must ensure that no mutating hash table operations</span>
<a name="l01071"></a>01071 <span class="comment">     * occur between a pair of |lookupForAdd| and |add| calls. To avoid</span>
<a name="l01072"></a>01072 <span class="comment">     * looking up the key a second time, the caller may use the more efficient</span>
<a name="l01073"></a>01073 <span class="comment">     * relookupOrAdd method. This method reuses part of the hashing computation</span>
<a name="l01074"></a>01074 <span class="comment">     * to more efficiently insert the key if it has not been added. For</span>
<a name="l01075"></a>01075 <span class="comment">     * example, a mutation-handling version of the previous example:</span>
<a name="l01076"></a>01076 <span class="comment">     *</span>
<a name="l01077"></a>01077 <span class="comment">     *    HM::AddPtr p = h.lookupForAdd(3);</span>
<a name="l01078"></a>01078 <span class="comment">     *    if (!p) {</span>
<a name="l01079"></a>01079 <span class="comment">     *      call_that_may_mutate_h();</span>
<a name="l01080"></a>01080 <span class="comment">     *      if (!h.relookupOrAdd(p, 3, &#39;a&#39;))</span>
<a name="l01081"></a>01081 <span class="comment">     *        return false;</span>
<a name="l01082"></a>01082 <span class="comment">     *    }</span>
<a name="l01083"></a>01083 <span class="comment">     *    const HM::Entry &amp;e = *p;</span>
<a name="l01084"></a>01084 <span class="comment">     *    assert(p-&gt;key == 3);</span>
<a name="l01085"></a>01085 <span class="comment">     *    char val = p-&gt;value;</span>
<a name="l01086"></a>01086 <span class="comment">     */</span>
<a name="l01087"></a>01087     <span class="keyword">typedef</span> <span class="keyword">typename</span> Impl::AddPtr AddPtr;
<a name="l01088"></a>01088     AddPtr lookupForAdd(<span class="keyword">const</span> Lookup &amp;l)<span class="keyword"> const </span>{
<a name="l01089"></a>01089         <span class="keywordflow">return</span> impl.lookupForAdd(l);
<a name="l01090"></a>01090     }
<a name="l01091"></a>01091 
<a name="l01092"></a>01092     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeyInput, <span class="keyword">typename</span> ValueInput&gt;
<a name="l01093"></a>01093     <span class="keywordtype">bool</span> add(AddPtr &amp;p, <span class="keyword">const</span> KeyInput &amp;k, <span class="keyword">const</span> ValueInput &amp;v) {
<a name="l01094"></a>01094         Entry *pentry;
<a name="l01095"></a>01095         <span class="keywordflow">if</span> (!impl.add(p, &amp;pentry))
<a name="l01096"></a>01096             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01097"></a>01097         <span class="keyword">const_cast&lt;</span>Key &amp;<span class="keyword">&gt;</span>(pentry-&gt;key) = k;
<a name="l01098"></a>01098         pentry-&gt;value = v;
<a name="l01099"></a>01099         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01100"></a>01100     }
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     <span class="keywordtype">bool</span> add(AddPtr &amp;p, <span class="keyword">const</span> Key &amp;k, MoveRef&lt;Value&gt; v) {
<a name="l01103"></a>01103         Entry *pentry;
<a name="l01104"></a>01104         <span class="keywordflow">if</span> (!impl.add(p, &amp;pentry))
<a name="l01105"></a>01105             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01106"></a>01106         <span class="keyword">const_cast&lt;</span>Key &amp;<span class="keyword">&gt;</span>(pentry-&gt;key) = k;
<a name="l01107"></a>01107         pentry-&gt;value = v;
<a name="l01108"></a>01108         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01109"></a>01109     }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111     <span class="keywordtype">bool</span> add(AddPtr &amp;p, <span class="keyword">const</span> Key &amp;k) {
<a name="l01112"></a>01112         Entry *pentry;
<a name="l01113"></a>01113         <span class="keywordflow">if</span> (!impl.add(p, &amp;pentry))
<a name="l01114"></a>01114             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01115"></a>01115         <span class="keyword">const_cast&lt;</span>Key &amp;<span class="keyword">&gt;</span>(pentry-&gt;key) = k;
<a name="l01116"></a>01116         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01117"></a>01117     }
<a name="l01118"></a>01118 
<a name="l01119"></a>01119     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeyInput, <span class="keyword">typename</span> ValueInput&gt;
<a name="l01120"></a>01120     <span class="keywordtype">bool</span> relookupOrAdd(AddPtr &amp;p, <span class="keyword">const</span> KeyInput &amp;k, <span class="keyword">const</span> ValueInput &amp;v) {
<a name="l01121"></a>01121         <span class="keywordflow">return</span> impl.relookupOrAdd(p, k, Entry(k, v));
<a name="l01122"></a>01122     }
<a name="l01123"></a>01123 
<a name="l01124"></a>01124     <span class="comment">/*</span>
<a name="l01125"></a>01125 <span class="comment">     * |all()| returns a Range containing |count()| elements. E.g.:</span>
<a name="l01126"></a>01126 <span class="comment">     *</span>
<a name="l01127"></a>01127 <span class="comment">     *   typedef HashMap&lt;int,char&gt; HM;</span>
<a name="l01128"></a>01128 <span class="comment">     *   HM h;</span>
<a name="l01129"></a>01129 <span class="comment">     *   for (HM::Range r = h.all(); !r.empty(); r.popFront())</span>
<a name="l01130"></a>01130 <span class="comment">     *     char c = r.front().value;</span>
<a name="l01131"></a>01131 <span class="comment">     *</span>
<a name="l01132"></a>01132 <span class="comment">     * Also see the definition of Range in HashTable above (with T = Entry).</span>
<a name="l01133"></a>01133 <span class="comment">     */</span>
<a name="l01134"></a>01134     <span class="keyword">typedef</span> <span class="keyword">typename</span> Impl::Range Range;
<a name="l01135"></a>01135     Range all()<span class="keyword"> const                                 </span>{ <span class="keywordflow">return</span> impl.all(); }
<a name="l01136"></a>01136     uint32_t count()<span class="keyword"> const                            </span>{ <span class="keywordflow">return</span> impl.count(); }
<a name="l01137"></a>01137     <span class="keywordtype">size_t</span> capacity()<span class="keyword"> const                           </span>{ <span class="keywordflow">return</span> impl.capacity(); }
<a name="l01138"></a>01138     <span class="keywordtype">size_t</span> sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf)<span class="keyword"> const </span>{
<a name="l01139"></a>01139         <span class="keywordflow">return</span> impl.sizeOfExcludingThis(mallocSizeOf);
<a name="l01140"></a>01140     }
<a name="l01141"></a>01141     <span class="keywordtype">size_t</span> sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf)<span class="keyword"> const </span>{
<a name="l01142"></a>01142         <span class="comment">/*</span>
<a name="l01143"></a>01143 <span class="comment">         * Don&#39;t just call |impl.sizeOfExcludingThis()| because there&#39;s no</span>
<a name="l01144"></a>01144 <span class="comment">         * guarantee that |impl| is the first field in HashMap.</span>
<a name="l01145"></a>01145 <span class="comment">         */</span>
<a name="l01146"></a>01146         <span class="keywordflow">return</span> mallocSizeOf(<span class="keyword">this</span>) + impl.sizeOfExcludingThis(mallocSizeOf);
<a name="l01147"></a>01147     }
<a name="l01148"></a>01148 
<a name="l01149"></a>01149     <span class="comment">/*</span>
<a name="l01150"></a>01150 <span class="comment">     * Typedef for the enumeration class. An Enum may be used to examine and</span>
<a name="l01151"></a>01151 <span class="comment">     * remove table entries:</span>
<a name="l01152"></a>01152 <span class="comment">     *</span>
<a name="l01153"></a>01153 <span class="comment">     *   typedef HashMap&lt;int,char&gt; HM;</span>
<a name="l01154"></a>01154 <span class="comment">     *   HM s;</span>
<a name="l01155"></a>01155 <span class="comment">     *   for (HM::Enum e(s); !e.empty(); e.popFront())</span>
<a name="l01156"></a>01156 <span class="comment">     *     if (e.front().value == &#39;l&#39;)</span>
<a name="l01157"></a>01157 <span class="comment">     *       e.removeFront();</span>
<a name="l01158"></a>01158 <span class="comment">     *</span>
<a name="l01159"></a>01159 <span class="comment">     * Table resize may occur in Enum&#39;s destructor. Also see the definition of</span>
<a name="l01160"></a>01160 <span class="comment">     * Enum in HashTable above (with T = Entry).</span>
<a name="l01161"></a>01161 <span class="comment">     */</span>
<a name="l01162"></a>01162     <span class="keyword">typedef</span> <span class="keyword">typename</span> Impl::Enum Enum;
<a name="l01163"></a>01163 
<a name="l01164"></a>01164     <span class="comment">/*</span>
<a name="l01165"></a>01165 <span class="comment">     * Remove all entries. This does not shrink the table. For that consider</span>
<a name="l01166"></a>01166 <span class="comment">     * using the finish() method.</span>
<a name="l01167"></a>01167 <span class="comment">     */</span>
<a name="l01168"></a>01168     <span class="keywordtype">void</span> clear()                                      { impl.clear(); }
<a name="l01169"></a>01169 
<a name="l01170"></a>01170     <span class="comment">/*</span>
<a name="l01171"></a>01171 <span class="comment">     * Remove all the entries and release all internal buffers. The map must</span>
<a name="l01172"></a>01172 <span class="comment">     * be initialized again before any use.</span>
<a name="l01173"></a>01173 <span class="comment">     */</span>
<a name="l01174"></a>01174     <span class="keywordtype">void</span> finish()                                     { impl.finish(); }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176    <span class="comment">/* Does the table contain any entries? */</span>
<a name="l01177"></a>01177     <span class="keywordtype">bool</span> empty()<span class="keyword"> const                                </span>{ <span class="keywordflow">return</span> impl.empty(); }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     <span class="comment">/*</span>
<a name="l01180"></a>01180 <span class="comment">     * If |generation()| is the same before and after a HashMap operation,</span>
<a name="l01181"></a>01181 <span class="comment">     * pointers into the table remain valid.</span>
<a name="l01182"></a>01182 <span class="comment">     */</span>
<a name="l01183"></a>01183     <span class="keywordtype">unsigned</span> generation()<span class="keyword"> const                       </span>{ <span class="keywordflow">return</span> impl.generation(); }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185     <span class="comment">/* Shorthand operations: */</span>
<a name="l01186"></a>01186 
<a name="l01187"></a>01187     <span class="keywordtype">bool</span> has(<span class="keyword">const</span> Lookup &amp;l)<span class="keyword"> const </span>{
<a name="l01188"></a>01188         <span class="keywordflow">return</span> impl.lookup(l) != NULL;
<a name="l01189"></a>01189     }
<a name="l01190"></a>01190 
<a name="l01191"></a>01191     <span class="comment">/* Overwrite existing value with v. Return false on oom. */</span>
<a name="l01192"></a>01192     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeyInput, <span class="keyword">typename</span> ValueInput&gt;
<a name="l01193"></a>01193     <span class="keywordtype">bool</span> put(<span class="keyword">const</span> KeyInput &amp;k, <span class="keyword">const</span> ValueInput &amp;v) {
<a name="l01194"></a>01194         AddPtr p = lookupForAdd(k);
<a name="l01195"></a>01195         <span class="keywordflow">if</span> (p) {
<a name="l01196"></a>01196             p-&gt;value = v;
<a name="l01197"></a>01197             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01198"></a>01198         }
<a name="l01199"></a>01199         <span class="keywordflow">return</span> add(p, k, v);
<a name="l01200"></a>01200     }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202     <span class="comment">/* Like put, but assert that the given key is not already present. */</span>
<a name="l01203"></a>01203     <span class="keywordtype">bool</span> putNew(<span class="keyword">const</span> Key &amp;k, <span class="keyword">const</span> Value &amp;v) {
<a name="l01204"></a>01204         <span class="keywordflow">return</span> impl.putNew(k, Entry(k, v));
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207     <span class="comment">/* Add (k,defaultValue) if k no found. Return false-y Ptr on oom. */</span>
<a name="l01208"></a>01208     Ptr lookupWithDefault(<span class="keyword">const</span> Key &amp;k, <span class="keyword">const</span> Value &amp;defaultValue) {
<a name="l01209"></a>01209         AddPtr p = lookupForAdd(k);
<a name="l01210"></a>01210         <span class="keywordflow">if</span> (p)
<a name="l01211"></a>01211             <span class="keywordflow">return</span> p;
<a name="l01212"></a>01212         (void)add(p, k, defaultValue);  <span class="comment">/* p is left false-y on oom. */</span>
<a name="l01213"></a>01213         <span class="keywordflow">return</span> p;
<a name="l01214"></a>01214     }
<a name="l01215"></a>01215 
<a name="l01216"></a>01216     <span class="comment">/* Remove if present. */</span>
<a name="l01217"></a>01217     <span class="keywordtype">void</span> <span class="keyword">remove</span>(<span class="keyword">const</span> Lookup &amp;l) {
<a name="l01218"></a>01218         <span class="keywordflow">if</span> (Ptr p = lookup(l))
<a name="l01219"></a>01219             <span class="keyword">remove</span>(p);
<a name="l01220"></a>01220     }
<a name="l01221"></a>01221 };
<a name="l01222"></a>01222 
<a name="l01223"></a>01223 <span class="comment">/*</span>
<a name="l01224"></a>01224 <span class="comment"> * JS-friendly, STL-like container providing a hash-based set of values. In</span>
<a name="l01225"></a>01225 <span class="comment"> * particular, HashSet calls constructors and destructors of all objects added</span>
<a name="l01226"></a>01226 <span class="comment"> * so non-PODs may be used safely.</span>
<a name="l01227"></a>01227 <span class="comment"> *</span>
<a name="l01228"></a>01228 <span class="comment"> * T requirements:</span>
<a name="l01229"></a>01229 <span class="comment"> *  - default constructible, copyable, destructible, assignable</span>
<a name="l01230"></a>01230 <span class="comment"> * HashPolicy requirements:</span>
<a name="l01231"></a>01231 <span class="comment"> *  - see &quot;Hash policy&quot; above (default js::DefaultHasher&lt;Key&gt;)</span>
<a name="l01232"></a>01232 <span class="comment"> * AllocPolicy:</span>
<a name="l01233"></a>01233 <span class="comment"> *  - see &quot;Allocation policies&quot; in jsalloc.h</span>
<a name="l01234"></a>01234 <span class="comment"> *</span>
<a name="l01235"></a>01235 <span class="comment"> * N.B: HashSet is not reentrant: T/HashPolicy/AllocPolicy members called by</span>
<a name="l01236"></a>01236 <span class="comment"> *      HashSet must not call back into the same HashSet object.</span>
<a name="l01237"></a>01237 <span class="comment"> * N.B: Due to the lack of exception handling, the user must call |init()|.</span>
<a name="l01238"></a>01238 <span class="comment"> */</span>
<a name="l01239"></a>01239 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> HashPolicy = DefaultHasher&lt;T&gt;, <span class="keyword">class</span> AllocPolicy = TempAllocPolicy&gt;
<a name="l01240"></a>01240 <span class="keyword">class </span>HashSet
<a name="l01241"></a>01241 {
<a name="l01242"></a>01242     <span class="keyword">typedef</span> <span class="keyword">typename</span> HashPolicy::Lookup Lookup;
<a name="l01243"></a>01243 
<a name="l01244"></a>01244     <span class="comment">/* Implement HashSet in terms of HashTable. */</span>
<a name="l01245"></a>01245     <span class="keyword">struct </span>SetOps : HashPolicy {
<a name="l01246"></a>01246         <span class="keyword">typedef</span> T KeyType;
<a name="l01247"></a>01247         <span class="keyword">static</span> <span class="keyword">const</span> KeyType &amp;getKey(<span class="keyword">const</span> T &amp;t) { <span class="keywordflow">return</span> t; }
<a name="l01248"></a>01248         <span class="keyword">static</span> <span class="keywordtype">void</span> setKey(T &amp;t, KeyType &amp;k) { t = k; }
<a name="l01249"></a>01249     };
<a name="l01250"></a>01250     <span class="keyword">typedef</span> detail::HashTable&lt;const T, SetOps, AllocPolicy&gt; Impl;
<a name="l01251"></a>01251 
<a name="l01252"></a>01252     <span class="keyword">friend</span> <span class="keyword">class </span>Impl::Enum;
<a name="l01253"></a>01253 
<a name="l01254"></a>01254     <span class="comment">/* Not implicitly copyable (expensive). May add explicit |clone| later. */</span>
<a name="l01255"></a>01255     HashSet(<span class="keyword">const</span> HashSet &amp;);
<a name="l01256"></a>01256     HashSet &amp;operator=(<span class="keyword">const</span> HashSet &amp;);
<a name="l01257"></a>01257 
<a name="l01258"></a>01258     Impl impl;
<a name="l01259"></a>01259 
<a name="l01260"></a>01260   <span class="keyword">public</span>:
<a name="l01261"></a>01261     <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> sDefaultInitSize = Impl::sDefaultInitSize;
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     <span class="comment">/*</span>
<a name="l01264"></a>01264 <span class="comment">     * HashSet construction is fallible (due to OOM); thus the user must call</span>
<a name="l01265"></a>01265 <span class="comment">     * init after constructing a HashSet and check the return value.</span>
<a name="l01266"></a>01266 <span class="comment">     */</span>
<a name="l01267"></a>01267     HashSet(<a class="code" href="class_alloc_policy.html">AllocPolicy</a> a = <a class="code" href="class_alloc_policy.html">AllocPolicy</a>()) : impl(a)  {}
<a name="l01268"></a>01268     <span class="keywordtype">bool</span> init(uint32_t len = sDefaultInitSize)        { <span class="keywordflow">return</span> impl.init(len); }
<a name="l01269"></a>01269     <span class="keywordtype">bool</span> initialized()<span class="keyword"> const                          </span>{ <span class="keywordflow">return</span> impl.initialized(); }
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     <span class="comment">/*</span>
<a name="l01272"></a>01272 <span class="comment">     * Return whether the given lookup value is present in the map. E.g.:</span>
<a name="l01273"></a>01273 <span class="comment">     *</span>
<a name="l01274"></a>01274 <span class="comment">     *   typedef HashSet&lt;int&gt; HS;</span>
<a name="l01275"></a>01275 <span class="comment">     *   HS h;</span>
<a name="l01276"></a>01276 <span class="comment">     *   if (HS::Ptr p = h.lookup(3)) {</span>
<a name="l01277"></a>01277 <span class="comment">     *     assert(*p == 3);   // p acts like a pointer to int</span>
<a name="l01278"></a>01278 <span class="comment">     *   }</span>
<a name="l01279"></a>01279 <span class="comment">     *</span>
<a name="l01280"></a>01280 <span class="comment">     * Also see the definition of Ptr in HashTable above.</span>
<a name="l01281"></a>01281 <span class="comment">     */</span>
<a name="l01282"></a>01282     <span class="keyword">typedef</span> <span class="keyword">typename</span> Impl::Ptr Ptr;
<a name="l01283"></a>01283     Ptr lookup(<span class="keyword">const</span> Lookup &amp;l)<span class="keyword"> const                 </span>{ <span class="keywordflow">return</span> impl.lookup(l); }
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     <span class="comment">/* Assuming |p.found()|, remove |*p|. */</span>
<a name="l01286"></a>01286     <span class="keywordtype">void</span> <span class="keyword">remove</span>(Ptr p)                                { impl.remove(p); }
<a name="l01287"></a>01287 
<a name="l01288"></a>01288     <span class="comment">/*</span>
<a name="l01289"></a>01289 <span class="comment">     * Like |lookup(l)|, but on miss, |p = lookupForAdd(l)| allows efficient</span>
<a name="l01290"></a>01290 <span class="comment">     * insertion of T value |t| (where |HashPolicy::match(t,l) == true|) using</span>
<a name="l01291"></a>01291 <span class="comment">     * |add(p,t)|. After |add(p,t)|, |p| points to the new element. E.g.:</span>
<a name="l01292"></a>01292 <span class="comment">     *</span>
<a name="l01293"></a>01293 <span class="comment">     *   typedef HashSet&lt;int&gt; HS;</span>
<a name="l01294"></a>01294 <span class="comment">     *   HS h;</span>
<a name="l01295"></a>01295 <span class="comment">     *   HS::AddPtr p = h.lookupForAdd(3);</span>
<a name="l01296"></a>01296 <span class="comment">     *   if (!p) {</span>
<a name="l01297"></a>01297 <span class="comment">     *     if (!h.add(p, 3))</span>
<a name="l01298"></a>01298 <span class="comment">     *       return false;</span>
<a name="l01299"></a>01299 <span class="comment">     *   }</span>
<a name="l01300"></a>01300 <span class="comment">     *   assert(*p == 3);   // p acts like a pointer to int</span>
<a name="l01301"></a>01301 <span class="comment">     *</span>
<a name="l01302"></a>01302 <span class="comment">     * Also see the definition of AddPtr in HashTable above.</span>
<a name="l01303"></a>01303 <span class="comment">     *</span>
<a name="l01304"></a>01304 <span class="comment">     * N.B. The caller must ensure that no mutating hash table operations</span>
<a name="l01305"></a>01305 <span class="comment">     * occur between a pair of |lookupForAdd| and |add| calls. To avoid</span>
<a name="l01306"></a>01306 <span class="comment">     * looking up the key a second time, the caller may use the more efficient</span>
<a name="l01307"></a>01307 <span class="comment">     * relookupOrAdd method. This method reuses part of the hashing computation</span>
<a name="l01308"></a>01308 <span class="comment">     * to more efficiently insert the key if it has not been added. For</span>
<a name="l01309"></a>01309 <span class="comment">     * example, a mutation-handling version of the previous example:</span>
<a name="l01310"></a>01310 <span class="comment">     *</span>
<a name="l01311"></a>01311 <span class="comment">     *    HS::AddPtr p = h.lookupForAdd(3);</span>
<a name="l01312"></a>01312 <span class="comment">     *    if (!p) {</span>
<a name="l01313"></a>01313 <span class="comment">     *      call_that_may_mutate_h();</span>
<a name="l01314"></a>01314 <span class="comment">     *      if (!h.relookupOrAdd(p, 3, 3))</span>
<a name="l01315"></a>01315 <span class="comment">     *        return false;</span>
<a name="l01316"></a>01316 <span class="comment">     *    }</span>
<a name="l01317"></a>01317 <span class="comment">     *    assert(*p == 3);</span>
<a name="l01318"></a>01318 <span class="comment">     *</span>
<a name="l01319"></a>01319 <span class="comment">     * Note that relookupOrAdd(p,l,t) performs Lookup using l and adds the</span>
<a name="l01320"></a>01320 <span class="comment">     * entry t, where the caller ensures match(l,t).</span>
<a name="l01321"></a>01321 <span class="comment">     */</span>
<a name="l01322"></a>01322     <span class="keyword">typedef</span> <span class="keyword">typename</span> Impl::AddPtr AddPtr;
<a name="l01323"></a>01323     AddPtr lookupForAdd(<span class="keyword">const</span> Lookup &amp;l)<span class="keyword"> const </span>{
<a name="l01324"></a>01324         <span class="keywordflow">return</span> impl.lookupForAdd(l);
<a name="l01325"></a>01325     }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327     <span class="keywordtype">bool</span> add(AddPtr &amp;p, <span class="keyword">const</span> T &amp;t) {
<a name="l01328"></a>01328         <span class="keywordflow">return</span> impl.add(p, t);
<a name="l01329"></a>01329     }
<a name="l01330"></a>01330 
<a name="l01331"></a>01331     <span class="keywordtype">bool</span> relookupOrAdd(AddPtr &amp;p, <span class="keyword">const</span> Lookup &amp;l, <span class="keyword">const</span> T &amp;t) {
<a name="l01332"></a>01332         <span class="keywordflow">return</span> impl.relookupOrAdd(p, l, t);
<a name="l01333"></a>01333     }
<a name="l01334"></a>01334 
<a name="l01335"></a>01335     <span class="comment">/*</span>
<a name="l01336"></a>01336 <span class="comment">     * |all()| returns a Range containing |count()| elements:</span>
<a name="l01337"></a>01337 <span class="comment">     *</span>
<a name="l01338"></a>01338 <span class="comment">     *   typedef HashSet&lt;int&gt; HS;</span>
<a name="l01339"></a>01339 <span class="comment">     *   HS h;</span>
<a name="l01340"></a>01340 <span class="comment">     *   for (HS::Range r = h.all(); !r.empty(); r.popFront())</span>
<a name="l01341"></a>01341 <span class="comment">     *     int i = r.front();</span>
<a name="l01342"></a>01342 <span class="comment">     *</span>
<a name="l01343"></a>01343 <span class="comment">     * Also see the definition of Range in HashTable above.</span>
<a name="l01344"></a>01344 <span class="comment">     */</span>
<a name="l01345"></a>01345     <span class="keyword">typedef</span> <span class="keyword">typename</span> Impl::Range Range;
<a name="l01346"></a>01346     Range all()<span class="keyword"> const                                 </span>{ <span class="keywordflow">return</span> impl.all(); }
<a name="l01347"></a>01347     uint32_t count()<span class="keyword"> const                            </span>{ <span class="keywordflow">return</span> impl.count(); }
<a name="l01348"></a>01348     <span class="keywordtype">size_t</span> capacity()<span class="keyword"> const                           </span>{ <span class="keywordflow">return</span> impl.capacity(); }
<a name="l01349"></a>01349     <span class="keywordtype">size_t</span> sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf)<span class="keyword"> const </span>{
<a name="l01350"></a>01350         <span class="keywordflow">return</span> impl.sizeOfExcludingThis(mallocSizeOf);
<a name="l01351"></a>01351     }
<a name="l01352"></a>01352     <span class="keywordtype">size_t</span> sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf)<span class="keyword"> const </span>{
<a name="l01353"></a>01353         <span class="comment">/*</span>
<a name="l01354"></a>01354 <span class="comment">         * Don&#39;t just call |impl.sizeOfExcludingThis()| because there&#39;s no</span>
<a name="l01355"></a>01355 <span class="comment">         * guarantee that |impl| is the first field in HashSet.</span>
<a name="l01356"></a>01356 <span class="comment">         */</span>
<a name="l01357"></a>01357         <span class="keywordflow">return</span> mallocSizeOf(<span class="keyword">this</span>) + impl.sizeOfExcludingThis(mallocSizeOf);
<a name="l01358"></a>01358     }
<a name="l01359"></a>01359 
<a name="l01360"></a>01360     <span class="comment">/*</span>
<a name="l01361"></a>01361 <span class="comment">     * Typedef for the enumeration class. An Enum may be used to examine and</span>
<a name="l01362"></a>01362 <span class="comment">     * remove table entries:</span>
<a name="l01363"></a>01363 <span class="comment">     *</span>
<a name="l01364"></a>01364 <span class="comment">     *   typedef HashSet&lt;int&gt; HS;</span>
<a name="l01365"></a>01365 <span class="comment">     *   HS s;</span>
<a name="l01366"></a>01366 <span class="comment">     *   for (HS::Enum e(s); !e.empty(); e.popFront())</span>
<a name="l01367"></a>01367 <span class="comment">     *     if (e.front() == 42)</span>
<a name="l01368"></a>01368 <span class="comment">     *       e.removeFront();</span>
<a name="l01369"></a>01369 <span class="comment">     *</span>
<a name="l01370"></a>01370 <span class="comment">     * Table resize may occur in Enum&#39;s destructor. Also see the definition of</span>
<a name="l01371"></a>01371 <span class="comment">     * Enum in HashTable above.</span>
<a name="l01372"></a>01372 <span class="comment">     */</span>
<a name="l01373"></a>01373     <span class="keyword">typedef</span> <span class="keyword">typename</span> Impl::Enum Enum;
<a name="l01374"></a>01374 
<a name="l01375"></a>01375     <span class="comment">/*</span>
<a name="l01376"></a>01376 <span class="comment">     * Remove all entries. This does not shrink the table. For that consider</span>
<a name="l01377"></a>01377 <span class="comment">     * using the finish() method.</span>
<a name="l01378"></a>01378 <span class="comment">     */</span>
<a name="l01379"></a>01379     <span class="keywordtype">void</span> clear()                                      { impl.clear(); }
<a name="l01380"></a>01380 
<a name="l01381"></a>01381     <span class="comment">/*</span>
<a name="l01382"></a>01382 <span class="comment">     * Remove all the entries and release all internal buffers. The set must</span>
<a name="l01383"></a>01383 <span class="comment">     * be initialized again before any use.</span>
<a name="l01384"></a>01384 <span class="comment">     */</span>
<a name="l01385"></a>01385     <span class="keywordtype">void</span> finish()                                     { impl.finish(); }
<a name="l01386"></a>01386 
<a name="l01387"></a>01387     <span class="comment">/* Does the table contain any entries? */</span>
<a name="l01388"></a>01388     <span class="keywordtype">bool</span> empty()<span class="keyword"> const                                </span>{ <span class="keywordflow">return</span> impl.empty(); }
<a name="l01389"></a>01389 
<a name="l01390"></a>01390     <span class="comment">/*</span>
<a name="l01391"></a>01391 <span class="comment">     * If |generation()| is the same before and after a HashSet operation,</span>
<a name="l01392"></a>01392 <span class="comment">     * pointers into the table remain valid.</span>
<a name="l01393"></a>01393 <span class="comment">     */</span>
<a name="l01394"></a>01394     <span class="keywordtype">unsigned</span> generation()<span class="keyword"> const                       </span>{ <span class="keywordflow">return</span> impl.generation(); }
<a name="l01395"></a>01395 
<a name="l01396"></a>01396     <span class="comment">/* Shorthand operations: */</span>
<a name="l01397"></a>01397 
<a name="l01398"></a>01398     <span class="keywordtype">bool</span> has(<span class="keyword">const</span> Lookup &amp;l)<span class="keyword"> const </span>{
<a name="l01399"></a>01399         <span class="keywordflow">return</span> impl.lookup(l) != NULL;
<a name="l01400"></a>01400     }
<a name="l01401"></a>01401 
<a name="l01402"></a>01402     <span class="comment">/* Overwrite existing value with v. Return false on oom. */</span>
<a name="l01403"></a>01403     <span class="keywordtype">bool</span> put(<span class="keyword">const</span> T &amp;t) {
<a name="l01404"></a>01404         AddPtr p = lookupForAdd(t);
<a name="l01405"></a>01405         <span class="keywordflow">return</span> p ? <span class="keyword">true</span> : add(p, t);
<a name="l01406"></a>01406     }
<a name="l01407"></a>01407 
<a name="l01408"></a>01408     <span class="comment">/* Like put, but assert that the given key is not already present. */</span>
<a name="l01409"></a>01409     <span class="keywordtype">bool</span> putNew(<span class="keyword">const</span> T &amp;t) {
<a name="l01410"></a>01410         <span class="keywordflow">return</span> impl.putNew(t, t);
<a name="l01411"></a>01411     }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413     <span class="keywordtype">bool</span> putNew(<span class="keyword">const</span> Lookup &amp;l, <span class="keyword">const</span> T &amp;t) {
<a name="l01414"></a>01414         <span class="keywordflow">return</span> impl.putNew(l, t);
<a name="l01415"></a>01415     }
<a name="l01416"></a>01416 
<a name="l01417"></a>01417     <span class="keywordtype">void</span> <span class="keyword">remove</span>(<span class="keyword">const</span> Lookup &amp;l) {
<a name="l01418"></a>01418         <span class="keywordflow">if</span> (Ptr p = lookup(l))
<a name="l01419"></a>01419             <span class="keyword">remove</span>(p);
<a name="l01420"></a>01420     }
<a name="l01421"></a>01421 };
<a name="l01422"></a>01422 
<a name="l01423"></a>01423 }  <span class="comment">/* namespace js */</span>
<a name="l01424"></a>01424 
<a name="l01425"></a>01425 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>HashTable.h</b>      </li>

    <li class="footer">Generated on Wed Jan 30 2013 23:40:56 for cocos2d-iphone-2.1-beta4 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0 </li>
   </ul>
 </div>


</body>
</html>
